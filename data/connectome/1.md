### docs/connectome/event_model/PATTERNS_Connectome_Event_Model_Contract_And_Normalization_Patterns.md

$$$

# event_model — Patterns: Contract-First Event Stream for Stepper + Realtime

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
THIS:            PATTERNS_Connectome_Event_Model_Contract_And_Normalization_Patterns.md (you are here)
BEHAVIORS:       ./BEHAVIORS_Connectome_Event_Model_Observable_Event_Stream_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Event_Normalization_And_Rendering_Event_Synthesis.md
VALIDATION:      ./VALIDATION_Connectome_Event_Model_Invariants_And_Error_Conditions.md
HEALTH:          ./HEALTH_Connectome_Event_Model_Runtime_Verification_And_Signal_Coverage.md
SYNC:            ./SYNC_Connectome_Event_Model_Sync_Current_State.md

IMPL:            ? (planned TypeScript module under /connectome, see IMPLEMENTATION doc)
$$$

### Bidirectional Contract

**Before modifying this doc or the code:**

1. Read ALL docs in this chain first
2. Read the linked IMPL source file

**After modifying this doc:**

1. Update the IMPL source file to match, OR
2. Add a TODO in SYNC_*.md: "Docs updated, implementation needs: {what}"
3. Run health: `pnpm connectome:health event_model` (?)

**After modifying the code:**

1. Update this doc chain to match, OR
2. Add a TODO in SYNC_*.md: "Implementation changed, docs need: {what}"
3. Run health: `pnpm connectome:health event_model` (?)

---

## THE PROBLEM

The /connectome dashboard needs to represent **one truth** across multiple sources:

* stepper simulation events (Next-step)
* realtime SSE events (stream)
* derived events (highlight changes, progress timers, energy pulses)
* health signals (invariant pass/fail)

Without a **single canonical event model**, the UI will:

* drift into ad-hoc payload parsing
* duplicate logic (labels, colors, durations, triggers)
* break stepper vs realtime parity (two incompatible “flows”)
* lose the ability to do stable logging + copy/export

What’s wrong with NOT having this:

* the diagram becomes “pretty” but non-auditable
* the log becomes uncopyable / inconsistent
* the dashboard cannot be used by agents as a reliable debugging instrument

---

## THE PATTERN

**Contract-first stream normalization.**

Everything that happens in /connectome is expressed as a **FlowEvent**:

* ingest raw inputs (SSE payloads, stepper definitions, timers)
* normalize them into a strict schema
* render and log from the normalized schema only

Key insight:

> If the event model is stable and deterministic, the visualization can be replaced without losing meaning.
> The UI becomes a view over an event ledger, not a pile of animations.

---

## PRINCIPLES

### Principle 1: One schema to rule stepper + realtime

The same FlowEvent schema must represent:

* direct calls (solid edges)
* streams (dotted edges)
* async agent calls (dashed edges)
* hooks/timers (log + state transitions)

Why this matters:

* avoids parallel “demo mode” and “real mode” logic
* makes /connectome a real tool instead of a mock

### Principle 2: Deterministic normalization (no “presentation logic” in rendering)

Normalization decides:

* callType / trigger classification
* duration bucketing for log colors
* label formatting
* “unknown” handling as explicit `?`

Why this matters:

* rendering stays simple + replaceable
* health checks can validate normalization output

### Principle 3: Lossless transport; lossy display

Store more than you display:

* raw payloads are preserved (optional)
* display uses `payload_summary` and `rate_hint`

Why this matters:

* operators can audit later
* the UI stays readable

---

## DATA

| Source                    | Type   | Purpose / Description                            |
| ------------------------- | ------ | ------------------------------------------------ |
| connectome stepper script | OTHER  | Simulated events released one-by-one             |
| backend SSE stream        | STREAM | Realtime event source (moment_spoken, etc.)      |
| local timers              | OTHER  | Progress bar timings, tick cadence visualization |
| derived UI events         | OTHER  | Highlight changes, layout recomputation          |

---

## DEPENDENCIES

| Module              | Why We Depend On It                                            |
| ------------------- | -------------------------------------------------------------- |
| `state_store`       | Stores normalized events and current focus state               |
| `runtime_engine`    | Produces step releases + mode gating (stepper vs realtime)     |
| `edge_kit`          | Uses callType/trigger to style edges                           |
| `node_kit`          | Uses event stepKey + energy deltas to highlight node internals |
| `telemetry_adapter` | Converts SSE payloads into FlowEvent                           |

---

## INSPIRATIONS

* Event-sourcing (ledger of facts, many projections)
* Observability pipelines (normalize at ingestion, render later)
* Finite “call graph tracing” tools (spans + triggers + durations)

---

## SCOPE

### In Scope

* The **canonical FlowEvent schema** (fields, enums, constraints)
* Normalization rules (classification, defaults, “?” behavior)
* Stable formatting primitives used by the UI (duration buckets, label policy)
* Backward compatibility policy for schema changes

### Out of Scope

* Graph layout and rendering primitives → see: `flow_canvas`, `node_kit`, `edge_kit`
* Stepper sequencing logic → see: `runtime_engine`
* Realtime transport specifics (SSE/WebSocket) → see: `telemetry_adapter`
* Backend endpoint design → see: `backend_docks` (reserved)

---

## GAPS / IDEAS / QUESTIONS

* [ ] Decide whether `raw_payload` is stored by default or behind a debug toggle (privacy + size).
* [ ] Confirm the authoritative list of backend SSE event names (some are known; others may drift) → `?`
* [ ] Define energy delta semantics: absolute units or normalized 0..1 → `?`
* IDEA: adopt OpenTelemetry-like span IDs for causal chains (parent_event_id).
* QUESTION: do we need multi-edge events (fanout) or always one edge per event?
* QUESTION: should `duration_ms` be measured or declared when simulated? (likely both: `duration_ms_declared` vs `duration_ms_measured`)

---

### docs/connectome/event_model/BEHAVIORS_Connectome_Event_Model_Observable_Event_Stream_Effects.md

$$$

# event_model — Behaviors: Observable Effects of the FlowEvent Contract

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Event_Model_Contract_And_Normalization_Patterns.md
THIS:            BEHAVIORS_Connectome_Event_Model_Observable_Event_Stream_Effects.md (you are here)
ALGORITHM:       ./ALGORITHM_Connectome_Event_Normalization_And_Rendering_Event_Synthesis.md
VALIDATION:      ./VALIDATION_Connectome_Event_Model_Invariants_And_Error_Conditions.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Event_Model_Code_Architecture_And_Schema.md
HEALTH:          ./HEALTH_Connectome_Event_Model_Runtime_Verification_And_Signal_Coverage.md
SYNC:            ./SYNC_Connectome_Event_Model_Sync_Current_State.md

IMPL:            ? (planned TypeScript module under /connectome)
$$$

> **Contract:** Read docs before modifying. After changes: update IMPL or add TODO to SYNC. Run health.

---

## BEHAVIORS

### B1: Stepper and realtime produce the same visual semantics

$$$
GIVEN:  A step is released by the stepper OR an SSE payload is received
WHEN:   The input is normalized into a FlowEvent
THEN:   The UI can render the same edge styling, node highlighting, and log formatting
AND:    The log entry is copy/export identical (modulo timestamps)
$$$

### B2: Unclear data becomes explicit, never silently dropped

$$$
GIVEN:  A missing or unknown field is encountered (event name, endpoint, duration, rate)
WHEN:   The normalization runs
THEN:   The normalized event includes `notes="?"` (or field value "?") rather than omitting the event
AND:    The UI shows a visible “?” marker in hover or log
$$$

### B3: Duration is always meaningful to the user

$$$
GIVEN:  An event duration is declared or measured
WHEN:   The log is rendered
THEN:   The duration is displayed with a stable unit rule (ms vs s)
AND:    The duration is color-coded by thresholds (ms blue; <1s green; <2s yellow; <3s orange; else red)
$$$

### B4: Trigger type drives both diagram styling and log styling

$$$
GIVEN:  A FlowEvent has trigger in {direct, stream, async, hook, timer}
WHEN:   The event is rendered
THEN:   The edge dash style matches trigger semantics (solid/dotted/dashed)
AND:    The log includes a trigger badge colored per trigger type
$$$

### B5: Schema evolution does not break existing renderers

$$$
GIVEN:  A new optional field is added to FlowEvent
WHEN:   Older code consumes it
THEN:   Rendering and logging remain correct using existing required fields
AND:    Unknown fields are ignored without data loss (raw payload can retain them)
$$$

---

## INPUTS / OUTPUTS

### Primary Function: `normalize_flow_event(raw)`

**Inputs:**

| Parameter        | Type      | Description                                                   |
| ---------------- | --------- | ------------------------------------------------------------- |
| `raw`            | `unknown` | Any input event (stepper definition, SSE payload, timer tick) |
| `source`         | `enum`    | `stepper` | `sse` | `derived`                                 |
| `received_at_ms` | `number`  | Local receipt time (monotonic preferred)                      |

**Outputs:**

| Return  | Type        | Description                                |
| ------- | ----------- | ------------------------------------------ |
| `event` | `FlowEvent` | Normalized event object with strict schema |

**Side Effects:**

* None required (pure transform). Storage happens in `state_store`.

---

## EDGE CASES

### E1: Missing node ids

$$$
GIVEN:  raw event lacks from/to node ids
THEN:   normalize_flow_event returns event with from="?" or to="?"
AND:    validation marks it as WARN/ERROR (depending on policy)
$$$

### E2: Negative or zero durations

$$$
GIVEN:  duration_ms <= 0
THEN:   duration_ms is clamped to minimum 200ms for animation
AND:    original value is preserved in notes/raw payload if available
$$$

---

## ANTI-BEHAVIORS

What should NOT happen:

### A1: Presentation logic re-implements normalization

$$$
GIVEN:   UI needs a label, color, or dash style
WHEN:    UI code tries to infer it from arbitrary payload fields
MUST NOT: Duplicate normalization logic in rendering
INSTEAD: Use normalized callType/trigger/label fields from FlowEvent
$$$

### A2: Dropping events because they are “unknown”

$$$
GIVEN:   an unrecognized SSE event name is received
WHEN:    normalization runs
MUST NOT: discard the event
INSTEAD: map it to callType="code" trigger="stream" with notes="?" and preserve raw payload
$$$

---

## GAPS / IDEAS / QUESTIONS

* [ ] Confirm whether we need `parent_event_id` for causal tracing in V1 (nice-to-have).
* QUESTION: Do we treat “graph link energy flow” as callType=graphLink or as a derived visualization event?
* IDEA: Provide a “strict mode” toggle that fails hard on schema violations (agent debugging).

---

### docs/connectome/event_model/ALGORITHM_Connectome_Event_Normalization_And_Rendering_Event_Synthesis.md

$$$

# event_model — Algorithm: Normalizing Inputs into FlowEvents

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Event_Model_Contract_And_Normalization_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Event_Model_Observable_Event_Stream_Effects.md
THIS:            ALGORITHM_Connectome_Event_Normalization_And_Rendering_Event_Synthesis.md (you are here)
VALIDATION:      ./VALIDATION_Connectome_Event_Model_Invariants_And_Error_Conditions.md
HEALTH:          ./HEALTH_Connectome_Event_Model_Runtime_Verification_And_Signal_Coverage.md
SYNC:            ./SYNC_Connectome_Event_Model_Sync_Current_State.md

IMPL:            ? (planned TypeScript module under /connectome)
$$$

> **Contract:** Read docs before modifying. After changes: update IMPL or add TODO to SYNC. Run health.

---

## OVERVIEW

This module converts heterogeneous inputs (stepper steps, SSE payloads, timers, derived UI transitions) into a single canonical structure: **FlowEvent**.

The output is used by:

* edge styling (type, color, directionality)
* node highlighting (stepKey, flipped glow, energy changes)
* unified explain/log panel (durations, triggers, payload summaries)
* export/copy (stable machine-readable event ledger)

---

## DATA STRUCTURES

### `FlowEvent`

$$$
FlowEvent:
required:
id: string                # stable unique id for this event
at_ms: number             # time of occurrence (monotonic preferred)
from_node_id: string      # source node id OR "?"
to_node_id: string        # target node id OR "?"
trigger: TriggerKind      # direct|stream|async|hook|timer
call_type: CallType       # code|graphQuery|llm|graphLink|moment
label: string             # short link label (NOT bold in UI)
optional:
duration_ms: number       # measured or declared; for animation and log
payload_summary: string   # short “what data moved”
rate_hint: string         # “per tick”, “<=3/tick”, “per action”
step_key: string          # which node internal step is active
energy_delta: number      # magnitude of energy transfer/pulse
notes: string             # "?" or clarifying remarks
raw_payload: unknown      # stored only if debug enabled (?)
$$$

### `TriggerKind`

$$$
TriggerKind: direct | stream | async | hook | timer
$$$

### `CallType`

$$$
CallType: code | graphQuery | llm | graphLink | moment
$$$

---

## ALGORITHM: `normalize_flow_event(raw_input)`

### Step 1: Establish source + base envelope

* Determine `source_kind` = stepper | sse | derived | timer
* Create default fields:

  * `id` = stable id (see decision D1)
  * `at_ms` = received_at_ms
  * `from_node_id`/`to_node_id` = "?" until mapped

$$$
base = {
id, at_ms,
from_node_id: "?",
to_node_id: "?",
trigger: "direct",
call_type: "code",
label: "?",
notes: ""
}
$$$

### Step 2: Classify trigger + call type

* Map trigger:

  * stepper: use declared trigger
  * sse: trigger="stream"
  * timer: trigger="timer"
  * derived UI: trigger="hook" or "timer" depending on origin
* Map call_type:

  * endpoints, internal methods -> code
  * graph query functions -> graphQuery
  * world builder/narrator -> llm
  * ABOUT/THEN/SAID -> graphLink
  * moment lifecycle transitions -> moment

### Step 3: Map nodes and labels

* Resolve `from_node_id`, `to_node_id`, `label`
* If not resolvable, keep "?" and add `notes="?"`

### Step 4: Duration handling

* If `duration_ms` missing: set to `?` (undefined) and add notes if important
* If present: clamp to `min_animation_ms = 200`

### Step 5: Summaries and rate hints

* `payload_summary`: shortest truthful summary
* `rate_hint`: fill from known semantics:

  * tick edges: `rate=tick` with speed-based hint (if known)
  * SSE edges: `rate=per event`
  * agent edges: `rate=on sparse` or `rate=on flip` (often `?`)

### Step 6: Emit normalized FlowEvent

* Return normalized event
* Never throw; error conditions become notes + validation failures

---

## KEY DECISIONS

### D1: Event ID strategy

$$$
IF raw_input has stable id:
id = raw_input.id
ELSE IF (source_kind == stepper):
id = "step:" + step_index + ":" + step_key
ELSE:
id = "evt:" + hash(label, from_node_id, to_node_id, at_ms_bucket)
$$$

Rationale:

* ensures stepper replay is stable
* avoids id churn in logs
* supports “copy log then replay” workflows

### D2: Duration bucketing for log color

$$$
IF duration_ms is undefined:
color = "muted_unknown"
ELSE IF duration_ms < 1000:
color = "green"
ELSE IF duration_ms < 2000:
color = "yellow"
ELSE IF duration_ms < 3000:
color = "orange"
ELSE:
color = "red"
AND:
IF unit is ms (duration_ms < 1000):
duration_text_color = "blue"  # special rule: show ms as blue
$$$

---

## DATA FLOW

$$$
raw input (stepper / sse / timer)
↓
normalize_flow_event(raw)
↓
FlowEvent (canonical)
↓
render edge + highlight node step + append unified log entry
$$$

---

## COMPLEXITY

**Time:** O(1) per event — constant mapping + string formatting

**Space:** O(n) for stored event ledger (bounded by UI retention policy)

**Bottlenecks:**

* storing raw payloads unbounded (avoid by toggle + retention)
* too many events per second in realtime mode (needs throttling in `telemetry_adapter`)

---

## HELPER FUNCTIONS

### `infer_call_type(raw)`

**Purpose:** classify call type for edge coloring and node semantics

**Logic:** pattern match by declared step type, SSE event name, endpoint path, link name

### `format_payload_summary(raw)`

**Purpose:** produce short truthful “what data moved” summary

**Logic:** prefer `payload_summary` if declared; else map known SSE payloads; else `?`

---

## INTERACTIONS

| Module              | What We Call                 | What We Get               |
| ------------------- | ---------------------------- | ------------------------- |
| `telemetry_adapter` | `adapt_sse_payload_to_raw()` | raw input candidate       |
| `runtime_engine`    | `declare_stepper_step()`     | raw step definition       |
| `state_store`       | `append_event(event)`        | persistent ledger storage |

---

## GAPS / IDEAS / QUESTIONS

* [ ] Define retention policy for event ledger in realtime mode (max N, or time window).
* QUESTION: should “energy pulse” be represented as a FlowEvent or a derived rendering-only artifact?

---

### docs/connectome/event_model/VALIDATION_Connectome_Event_Model_Invariants_And_Error_Conditions.md

$$$

# event_model — Validation: Invariants for FlowEvent Correctness

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Event_Model_Contract_And_Normalization_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Event_Model_Observable_Event_Stream_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Event_Normalization_And_Rendering_Event_Synthesis.md
THIS:            VALIDATION_Connectome_Event_Model_Invariants_And_Error_Conditions.md (you are here)
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Event_Model_Code_Architecture_And_Schema.md
HEALTH:          ./HEALTH_Connectome_Event_Model_Runtime_Verification_And_Signal_Coverage.md
SYNC:            ./SYNC_Connectome_Event_Model_Sync_Current_State.md

IMPL:            ? (planned TypeScript module under /connectome)
$$$

> **Contract:** Read docs before modifying. After changes: update IMPL or add TODO to SYNC. Run health.

---

## INVARIANTS

These must ALWAYS be true:

### V1: Schema Completeness (Required Fields)

$$$
For every FlowEvent e:
e.id is non-empty string
e.at_ms is a finite number
e.from_node_id is non-empty string (or "?")
e.to_node_id is non-empty string (or "?")
e.trigger ∈ {direct, stream, async, hook, timer}
e.call_type ∈ {code, graphQuery, llm, graphLink, moment}
e.label is non-empty string (or "?")
$$$

**Checked by:** `health_check_event_schema_conformance`

### V2: Deterministic Normalization

$$$
Given identical raw input and identical normalization config:
normalize_flow_event(raw) produces identical FlowEvent (except at_ms if explicitly set to receipt time)
$$$

**Checked by:** `health_check_event_normalization_determinism` (stepper replay)

### V3: Animation Duration Safety

$$$
IF e.duration_ms exists:
e.duration_ms >= 200ms (clamped)
ELSE:
UI uses fallback >= 200ms
$$$

**Checked by:** `health_check_event_duration_clamping`

### V4: Monotonic Event Ledger (Local Order)

$$$
For the stored ledger L = [e0, e1, ...]:
at_ms is non-decreasing OR
(if out-of-order arrival happens) then ledger stores arrival_index and UI orders by arrival_index
$$$

**Checked by:** `health_check_event_ordering_policy` (?)

---

## PROPERTIES

### P1: Trigger ↔ Edge Style Correspondence

$$$
FORALL e:
e.trigger == direct  => edge style is solid
e.trigger == stream  => edge style is dotted
e.trigger == async   => edge style is dashed
e.trigger == hook    => edge style is dotted or special hook style (must be consistent)
e.trigger == timer   => edge style is dashed or timer style (must be consistent)
$$$

**Verified by:** `health_check_trigger_to_edge_style_mapping`

### P2: CallType ↔ Color Correspondence

$$$
FORALL e:
e.call_type == graphLink  => edge color ∈ {yellow, orange}
e.call_type == graphQuery => edge color == purple
e.call_type == code       => edge color == blue
e.call_type == llm        => edge color == green
e.call_type == moment     => node highlight color == yellow
$$$

**Verified by:** `health_check_calltype_color_mapping`

---

## ERROR CONDITIONS

### E1: Missing Node IDs

$$$
WHEN:    e.from_node_id == "?" OR e.to_node_id == "?"
THEN:    event is still stored and rendered
SYMPTOM: UI shows “?” in hover and log
$$$

**Verified by:** `health_check_unknown_nodes_are_not_dropped`

### E2: Unknown SSE Event Name

$$$
WHEN:    telemetry adapter receives unknown SSE event name
THEN:    event is mapped to trigger=stream, call_type=code, label="?"
SYMPTOM: UI log shows notes="?"
$$$

**Verified by:** `health_check_unknown_sse_is_preserved`

---

## HEALTH COVERAGE

| Invariant               | Signal             | Status             |
| ----------------------- | ------------------ | ------------------ |
| V1: Schema Completeness | schema_conformance | ⚠ NOT YET VERIFIED |
| V2: Determinism         | determinism        | ⚠ NOT YET VERIFIED |
| V3: Duration Safety     | duration_clamp     | ⚠ NOT YET VERIFIED |
| V4: Ordering Policy     | ordering           | ⚠ NOT YET VERIFIED |

---

## VERIFICATION PROCEDURE

### Manual Checklist

$$$
[ ] V1 holds — inspect exported log JSONL (required fields present)
[ ] V2 holds — replay stepper steps twice, diff output (except timestamps)
[ ] V3 holds — set duration_ms=10, verify animation uses >=200ms
[ ] V4 holds — simulate out-of-order SSE events, ensure UI stable ordering
[ ] All behaviors from BEHAVIORS file work
[ ] Unknown inputs show “?” rather than disappearing
$$$

### Automated

$$$

# Run health checks (module scoped)

pnpm connectome:health event_model
$$$

---

## SYNC STATUS

$$$
LAST_VERIFIED: 2025-12-20
VERIFIED_AGAINST:
impl: ? @ ?
health: ? @ ?
VERIFIED_BY: ?
RESULT:
V1: NOT RUN
V2: NOT RUN
V3: NOT RUN
V4: NOT RUN
$$$

---

## GAPS / IDEAS / QUESTIONS

* [ ] Decide exact ordering policy for realtime out-of-order events (by arrival vs by at_ms).
* QUESTION: Should “?” node ids be allowed in production or only in dev?

---

### docs/connectome/event_model/HEALTH_Connectome_Event_Model_Runtime_Verification_And_Signal_Coverage.md

$$$

# event_model — Health: Verification Mechanics and Coverage

STATUS: DRAFT
CREATED: 2025-12-20
$$$

---

## PURPOSE OF THIS FILE

This HEALTH file covers **runtime correctness** of the /connectome **FlowEvent model**, ensuring the dashboard’s event ledger remains reliable under both stepper and realtime ingestion.

It exists because:

* unit tests can pass while the dashboard silently drops events or mis-styles triggers
* realtime payloads can drift and break normalization without obvious compile errors

Boundaries:

* This file does NOT verify layout stability or rendering performance → see `flow_canvas`, `edge_kit`.
* This file does NOT verify backend truthfulness (Tempo/Canon invariants) → belongs to backend module health.

---

## WHY THIS PATTERN

HEALTH verifies input/output against VALIDATION without requiring invasive code edits, using docking points exposed by the connectome ingestion and store layers.

Failure mode avoided:

* “diagram looks fine” but events are misclassified, durations lie, or unknown payloads vanish.

Throttling matters:

* realtime mode can generate many events; checks must be bounded and meaningful.

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Event_Model_Contract_And_Normalization_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Event_Model_Observable_Event_Stream_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Event_Normalization_And_Rendering_Event_Synthesis.md
VALIDATION:      ./VALIDATION_Connectome_Event_Model_Invariants_And_Error_Conditions.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Event_Model_Code_Architecture_And_Schema.md
THIS:            HEALTH_Connectome_Event_Model_Runtime_Verification_And_Signal_Coverage.md
SYNC:            ./SYNC_Connectome_Event_Model_Sync_Current_State.md

IMPL:            ? (planned) scripts/connectome/health/event_model_health_check_runner.ts
$$$

---

## FLOWS ANALYSIS (TRIGGERS + FREQUENCY)

$$$
flows_analysis:

* flow_id: connectome_event_ingestion_and_normalization
  purpose: Wrong normalization breaks every downstream render + log meaning.
  triggers:

  * type: event
    source: connectome/telemetry_adapter:adapt_sse_payload_to_raw (?)
    notes: SSE payload arrives
  * type: manual
    source: connectome/runtime_engine:release_next_step (?)
    notes: user clicks Next step
    frequency:
    expected_rate: "stepper: <= 1/s (manual); realtime: ?/s"
    peak_rate: "realtime: ?/s (depends on Tempo + Canon output)"
    burst_behavior: "UI may buffer; health must sample not exhaust"
    risks:
  * "VALIDATION V1 schema completeness fails → events dropped or unreadable"
  * "VALIDATION V2 determinism fails → stepper not replayable"
    notes: "Realtime rates are unknown until telemetry adapter exists → ?"

* flow_id: connectome_event_ledger_storage_and_export
  purpose: If ledger corrupts, copy/export and auditing fail.
  triggers:

  * type: event
    source: connectome/state_store:append_event (?)
    notes: normalized event stored
    frequency:
    expected_rate: "matches ingestion"
    peak_rate: "matches ingestion"
    burst_behavior: "retention policy should cap memory → ?"
    risks:
  * "VALIDATION V4 ordering policy violated → confusing chronology"
    notes: "Retention window policy still TBD → ?"
    $$$

---

## HEALTH INDICATORS SELECTED

$$$
health_indicators:

* name: event_schema_conformance
  flow_id: connectome_event_ingestion_and_normalization
  priority: high
  rationale: "If required fields are missing, the dashboard cannot be trusted."

* name: event_duration_clamping
  flow_id: connectome_event_ingestion_and_normalization
  priority: med
  rationale: "If durations are unsafe, animations mislead the user."

* name: event_unknown_preservation
  flow_id: connectome_event_ingestion_and_normalization
  priority: high
  rationale: "Unknown inputs must not disappear; '?' must surface."

* name: event_ordering_policy
  flow_id: connectome_event_ledger_storage_and_export
  priority: med
  rationale: "Out-of-order events must still yield stable readable logs."
  $$$

---

## STATUS (RESULT INDICATOR)

$$$
status:
stream_destination: "file:?/var/connectome/health/event_model_status.json"
result:
representation: enum
value: UNKNOWN
updated_at: "2025-12-20T00:00:00+01:00"
source: event_schema_conformance
$$$

---

## DOCK TYPES (COMPLETE LIST)

Using standard dock types only (no custom needed for v1):

* `event` (stepper releases, SSE arrival)
* `stream` (SSE)
* `file` (exported log JSONL)
* `config` (normalization config / retention)

---

## CHECKER INDEX

$$$
checkers:

* name: health_check_event_schema_conformance
  purpose: "Verify VALIDATION V1 required fields always present."
  status: pending
  priority: high

* name: health_check_event_duration_clamping
  purpose: "Verify VALIDATION V3 duration min 200ms behavior."
  status: pending
  priority: med

* name: health_check_unknown_nodes_are_not_dropped
  purpose: "Verify VALIDATION E1: '?' preserved, event still logged."
  status: pending
  priority: high

* name: health_check_unknown_sse_is_preserved
  purpose: "Verify VALIDATION E2 mapping for unknown SSE event names."
  status: pending
  priority: high
  $$$

---

## INDICATOR: event_schema_conformance

### VALUE TO CLIENTS & VALIDATION MAPPING

$$$
value_and_validation:
indicator: event_schema_conformance
client_value: "Agents and humans can trust that every visible edge/log line has a complete meaning."
validation:
- validation_id: V1
criteria: "Schema completeness (required fields exist and are valid)"
$$$

### HEALTH REPRESENTATION

$$$
representation:
allowed: [binary, float_0_1, enum, tuple, vector]
selected: [enum]
semantics:
enum: "OK=all sampled events valid; WARN=some invalid but preserved with '?'; ERROR=invalid and dropped (must not happen)"
aggregation:
method: "worst_state"
display: "enum"
$$$

### DOCKS SELECTED

$$$
docks:
input:
id: dock_ingestion_normalized_event
method: state_store.append_event (?)
location: "connectome/state_store:?"
output:
id: dock_export_log_jsonl
method: log_panel.export_jsonl (?)
location: "connectome/log_panel:?"
$$$

### ALGORITHM / CHECK MECHANISM

$$$
mechanism:
summary: "Sample normalized events and assert required fields match VALIDATION V1."
steps:
- "Intercept or sample FlowEvent objects at append_event()"
- "Validate required fields and enum membership"
- "Emit OK/WARN/ERROR enum + counts"
data_required: "Normalized FlowEvent objects"
failure_mode: "Missing fields → WARN; any dropped event → ERROR"
$$$

### INDICATOR

$$$
indicator:
error:
- name: dropped_event_detected
linked_validation: [V1]
meaning: "An event failed schema and was discarded"
default_action: page
warning:
- name: schema_violation_preserved_with_unknowns
linked_validation: [V1]
meaning: "Event preserved but fields are '?'"
default_action: warn/log
info:
- name: sample_ok
linked_validation: [V1]
meaning: "Sampled events valid"
default_action: log/notify
$$$

### THROTTLING STRATEGY

$$$
throttling:
trigger: event
max_frequency: "1/5s"
burst_limit: 10
backoff: "exponential on repeated WARN/ERROR"
$$$

### FORWARDINGS & DISPLAYS

$$$
forwarding:
targets:
- location: "/connectome (UI panel) — event_model indicator badge"
transport: event
notes: "Human-visible status"
display:
locations:
- surface: UI
location: "/connectome log panel header"
signal: "green/ok, yellow/warn, red/error"
notes: "Badge + tooltip with counts"
$$$

### MANUAL RUN

$$$
manual_run:
command: "pnpm connectome:health event_model"
notes: "Run after changing FlowEvent schema or telemetry mapping."
$$$

---

## HOW TO RUN

$$$

# Run all health checks for this module

pnpm connectome:health event_model

# Run a specific checker

pnpm connectome:health event_model --checker health_check_event_schema_conformance
$$$

---

## KNOWN GAPS

* [ ] No real docking points exist yet (file:line unknown) → fill after initial implementation.
* [ ] Ordering policy for realtime out-of-order events unresolved → affects V4 coverage.
* [ ] Realtime expected/peak rates unknown → update once telemetry adapter exists.

---

## GAPS / IDEAS / QUESTIONS

* IDEA: Export health results to a stable JSON file consumed by ngram doctor.
* QUESTION: Should schema violations in production hard-fail (stop realtime mode) or degrade (WARN)?

---

### docs/connectome/event_model/SYNC_Connectome_Event_Model_Sync_Current_State.md

$$$

# event_model — Sync: Current State

LAST_UPDATED: 2025-12-20
UPDATED_BY: Marco "Salthand" (agent)
STATUS: DESIGNING
$$$

---

## MATURITY

**What's canonical (v1):**

* FlowEvent schema exists as the single contract for /connectome event meaning.
* Normalization is deterministic and never drops events (unknown → "?").

**What's still being designed:**

* exact backend SSE event list and payload shapes
* ordering policy under out-of-order realtime arrivals
* whether raw_payload is stored by default

**What's proposed (v2+):**

* parent_event_id causal tracing (span-like)
* OpenTelemetry-style export/import
* backend docks for richer telemetry snapshots

---

## CURRENT STATE

We are defining /connectome as an agent-first dashboard that renders from a single event ledger. The event_model module is the foundation: it specifies a canonical FlowEvent contract used by both stepper and realtime mode. Implementation does not exist yet; this chain is establishing the stable contract before code is written.

---

## IN PROGRESS

### V1 FlowEvent schema + normalization rules

* **Started:** 2025-12-20
* **By:** Marco "Salthand" (agent)
* **Status:** in progress
* **Context:** Without schema-first normalization, every other module duplicates meaning and drifts.

---

## RECENT CHANGES

### 2025-12-20: Initialized event_model chain docs

* **What:** Added PATTERNS/BEHAVIORS/ALGORITHM/VALIDATION/HEALTH/SYNC/IMPLEMENTATION drafts.
* **Why:** Establish stable contract first; unblock runtime_engine and telemetry_adapter.
* **Files:** docs/connectome/event_model/*
* **Struggles/Insights:** The hard part is deciding what is “unknown-but-preserved” vs “invalid”.

---

## KNOWN ISSUES

### Unknown backend payload shapes

* **Severity:** medium
* **Symptom:** realtime mapping cannot be finalized
* **Suspected cause:** SSE contracts may still be evolving elsewhere
* **Attempted:** Marked as `?` everywhere; deferred to telemetry_adapter and backend_docks

---

## HANDOFF: FOR AGENTS

**Your likely VIEW:** VIEW_Implement

**Where I stopped:** At “schema-first” definition for FlowEvent and normalization algorithm.

**What you need to understand:**

* Every visualization and log line must come from FlowEvent.
* Unknowns must be preserved as “?”; no silent dropping.

**Watch out for:**

* “helpful” UI logic that re-derives colors/labels from raw payloads (anti-pattern).
* Storing raw payloads unbounded (memory/privacy).

**Open questions I had:**

* ordering policy (arrival vs at_ms)
* whether parent_event_id is required for v1

---

## HANDOFF: FOR HUMAN

**Executive summary:**
We froze the FlowEvent contract as the foundation of /connectome. Everything else should consume normalized events only.

**Decisions made:**

* unknown inputs are preserved and surfaced as “?”
* duration animations clamp to minimum 200ms
* trigger and call_type drive styling and log badges

**Needs your input:**

* ordering policy for realtime events
* whether to store raw payloads by default

---

## TODO

### Doc/Impl Drift

* [ ] DOCS→IMPL: Implement FlowEvent types + normalize_flow_event() per ALGORITHM.
* [ ] DOCS→IMPL: Implement duration bucketing and trigger/callType mapping per VALIDATION.

### Health to Run

$$$
pnpm connectome:health event_model
$$$

### Immediate

* [ ] Create TypeScript file(s) and export FlowEvent schema + normalization
* [ ] Add minimal unit-level health harness to validate V1/V3

### Later

* [ ] Add replay determinism checker for stepper mode
* IDEA: add parent_event_id support once causal chains matter

---

## CONSCIOUSNESS TRACE

**Mental state when stopping:**
Clear. The contract is the real system; visuals can change.

**Threads I was holding:**

* keep schema stable; prevent drift
* keep unknown visible; never drop
* connect durations to user trust

**Intuitions:**

* schema must be more stable than UI and more stable than backend payloads

**What I wish I'd known at the start:**

* realtime ordering and retention must be decided early or you regret it later

---

## POINTERS

| What                   | Where            |
| ---------------------- | ---------------- |
| FlowEvent schema draft | `ALGORITHM_...`  |
| Invariants             | `VALIDATION_...` |
| Health plan            | `HEALTH_...`     |

---

### docs/connectome/event_model/IMPLEMENTATION_Connectome_Event_Model_Code_Architecture_And_Schema.md

$$$

# event_model — Implementation: Code Architecture and Structure

STATUS: DRAFT
CREATED: 2025-12-20
$$$

---

## CHAIN

$$$
PATTERNS:       ./PATTERNS_Connectome_Event_Model_Contract_And_Normalization_Patterns.md
BEHAVIORS:      ./BEHAVIORS_Connectome_Event_Model_Observable_Event_Stream_Effects.md
ALGORITHM:      ./ALGORITHM_Connectome_Event_Normalization_And_Rendering_Event_Synthesis.md
VALIDATION:     ./VALIDATION_Connectome_Event_Model_Invariants_And_Error_Conditions.md
THIS:           IMPLEMENTATION_Connectome_Event_Model_Code_Architecture_And_Schema.md
HEALTH:         ./HEALTH_Connectome_Event_Model_Runtime_Verification_And_Signal_Coverage.md
SYNC:           ./SYNC_Connectome_Event_Model_Sync_Current_State.md

IMPL:           app/connectome/lib/flow_event_schema_and_normalization_contract.ts (PROPOSED)
$$$

> **Contract:** Read docs before modifying. After changes: update IMPL or add TODO to SYNC. Run health.

---

## CODE STRUCTURE

$$$
app/
└── connectome/
├── lib/
│   ├── flow_event_schema_and_normalization_contract.ts     # exports FlowEvent + normalize_flow_event()
│   ├── flow_event_duration_bucket_color_classifier.ts      # duration->(text,color) rules
│   └── flow_event_trigger_and_calltype_inference_rules.ts  # mapping tables, kept deterministic
└── (other modules own rendering/store)
$$$

### File Responsibilities

| File                                                                    | Purpose                                              | Key Functions/Classes                       | Lines | Status |
| ----------------------------------------------------------------------- | ---------------------------------------------------- | ------------------------------------------- | ----- | ------ |
| `app/connectome/lib/flow_event_schema_and_normalization_contract.ts`    | Single source of truth for FlowEvent + normalization | `FlowEvent`, `normalize_flow_event()`       | ~200  | OK     |
| `app/connectome/lib/flow_event_duration_bucket_color_classifier.ts`     | Duration formatting + threshold coloring             | `format_duration_for_log()`                 | ~120  | OK     |
| `app/connectome/lib/flow_event_trigger_and_calltype_inference_rules.ts` | Deterministic mappings for trigger/callType          | `infer_trigger_kind()`, `infer_call_type()` | ~160  | OK     |

**Size Thresholds:**

* OK (<400 lines): Healthy size, easy to understand
* WATCH (400-700 lines): Getting large, consider extraction opportunities
* SPLIT (>700 lines): Too large, must split before adding more code

---

## DESIGN PATTERNS

### Architecture Pattern

**Pattern:** Pipeline / Normalization Boundary

**Why this pattern:** All upstream sources are heterogeneous; normalize once, render many ways.

### Code Patterns in Use

| Pattern              | Applied To                                           | Purpose                            |
| -------------------- | ---------------------------------------------------- | ---------------------------------- |
| Table-driven mapping | `flow_event_trigger_and_calltype_inference_rules.ts` | deterministic classification       |
| Pure functions       | `normalize_flow_event()`                             | testability + replay determinism   |
| Strict types         | `FlowEvent`                                          | schema stability for agents and UI |

### Anti-Patterns to Avoid

* **God Object**: Do not put store, rendering, and normalization into one file.
* **Premature Abstraction**: No “general event framework”; just FlowEvent.
* **UI-based inference**: UI must not re-infer callType/trigger from raw payloads.

### Boundaries

| Boundary               | Inside                 | Outside                 | Interface                |
| ---------------------- | ---------------------- | ----------------------- | ------------------------ |
| Normalization boundary | raw inputs → FlowEvent | UI rendering and layout | `normalize_flow_event()` |

---

## SCHEMA

### FlowEvent

$$$
FlowEvent:
required:
id: string
at_ms: number
from_node_id: string
to_node_id: string
trigger: direct|stream|async|hook|timer
call_type: code|graphQuery|llm|graphLink|moment
label: string
optional:
duration_ms: number
payload_summary: string
rate_hint: string
step_key: string
energy_delta: number
notes: string
raw_payload: unknown
constraints:
- "from_node_id/to_node_id may be '?' but must never be empty"
- "duration_ms (if present) must clamp to >= 200ms"
$$$

---

## ENTRY POINTS

| Entry Point              | File:Line                                           | Triggered By                                   |
| ------------------------ | --------------------------------------------------- | ---------------------------------------------- |
| `normalize_flow_event()` | `flow_event_schema_and_normalization_contract.ts:?` | stepper release, SSE ingestion, derived events |

---

## DATA FLOW AND DOCKING (FLOW-BY-FLOW)

### connectome_event_ingestion_and_normalization: raw input → FlowEvent

$$$
flow:
name: connectome_event_ingestion_and_normalization
purpose: Normalize heterogeneous inputs into a single contract for rendering/logging/health.
scope: raw input (stepper/SSE/timer) → FlowEvent
steps:
- id: step_1_capture_raw
description: Receive raw input and annotate source_kind + received_at_ms.
file: app/connectome/? (runtime_engine or telemetry_adapter)
function: capture_raw_input (?)
input: unknown
output: raw_envelope
trigger: "Next step" | "SSE event" | "timer"
side_effects: none
- id: step_2_normalize
description: Convert raw_envelope into FlowEvent using deterministic rules.
file: app/connectome/lib/flow_event_schema_and_normalization_contract.ts
function: normalize_flow_event
input: raw_envelope
output: FlowEvent
trigger: direct call
side_effects: none
- id: step_3_store
description: Append FlowEvent to ledger (store owns persistence).
file: app/connectome/? (state_store)
function: append_event (?)
input: FlowEvent
output: ledger_updated
trigger: direct call
side_effects: state mutation
docking_points:
guidance:
include_when: "schema boundary crossings; storage; export"
omit_when: "trivial format conversions"
selection_notes: "HEALTH should dock at normalize and at append_event"
available:
- id: dock_normalize_flow_event_output
type: event
direction: output
file: app/connectome/lib/flow_event_schema_and_normalization_contract.ts
function: normalize_flow_event
trigger: direct call
payload: FlowEvent
async_hook: not_applicable
needs: none
notes: "primary health dock for schema conformance"
- id: dock_append_event_ledger
type: event
direction: input
file: app/connectome/? (state_store)
function: append_event (?)
trigger: direct call
payload: FlowEvent
async_hook: not_applicable
needs: none
notes: "secondary health dock for ordering/retention"
health_recommended:
- dock_id: dock_normalize_flow_event_output
reason: "Directly validates V1/V2/V3 invariants at the contract boundary."
- dock_id: dock_append_event_ledger
reason: "Validates ledger ordering policy and export integrity."
$$$

---

## LOGIC CHAINS

### LC1: Normalize and store one event

$$$
raw_input
→ normalize_flow_event()                     # contract boundary
→ state_store.append_event()               # persistent ledger
→ log_panel.render_from_ledger()         # display + copy/export
$$$

---

## MODULE DEPENDENCIES

### Internal Dependencies

$$$
event_model
└── imported by → state_store
└── imported by → runtime_engine
└── imported by → telemetry_adapter
└── imported by → edge_kit (colors)
└── imported by → log_panel (formatting)
$$$

### External Dependencies

| Package            | Used For     | Imported By |
| ------------------ | ------------ | ----------- |
| none required (v1) | keep it pure | event_model |

---

## STATE MANAGEMENT

This module is stateless by design.

| State | Location | Scope | Lifecycle |
| ----- | -------- | ----- | --------- |
| none  | —        | —     | —         |

---

## RUNTIME BEHAVIOR

### Initialization

$$$

1. module loads mapping tables
2. exports FlowEvent type + normalization helpers
3. system ready
   $$$

### Main Cycle

$$$

1. raw input arrives (stepper/SSE/timer)
2. normalize_flow_event(raw) returns FlowEvent
3. store/app layers consume it
   $$$

---

## CONCURRENCY MODEL

Stateless and synchronous. Concurrency handled by callers (store/adapter).

---

## CONFIGURATION

| Config               | Location                                          | Default   | Description                        |
| -------------------- | ------------------------------------------------- | --------- | ---------------------------------- |
| `MIN_ANIMATION_MS`   | `flow_event_schema_and_normalization_contract.ts` | 200       | clamp for trustworthiness          |
| `STORE_RAW_PAYLOADS` | same                                              | false (?) | store raw payloads behind a toggle |
| `RETENTION_POLICY`   | caller (state_store)                              | ?         | how many events to keep            |

---

## BIDIRECTIONAL LINKS

### Code → Docs

To add during implementation:

| File                                              | Line | Reference                                                         |
| ------------------------------------------------- | ---- | ----------------------------------------------------------------- |
| `flow_event_schema_and_normalization_contract.ts` | ?    | `# DOCS: docs/connectome/event_model/IMPLEMENTATION_...md` |

### Docs → Code

| Doc Section                    | Implemented In                                                                 |
| ------------------------------ | ------------------------------------------------------------------------------ |
| ALGORITHM normalize_flow_event | `flow_event_schema_and_normalization_contract.ts:normalize_flow_event`         |
| VALIDATION V1                  | `event_model_health_check_runner.ts:health_check_event_schema_conformance` (?) |
| BEHAVIOR B3                    | `flow_event_duration_bucket_color_classifier.ts:format_duration_for_log`       |

---

## GAPS / IDEAS / QUESTIONS

### Extraction Candidates

None yet (v1 sizes are OK).

### Missing Implementation

* [ ] Create the three proposed TS files with long descriptive names.
* [ ] Provide a minimal health runner script entrypoint.

### Ideas

* IDEA: optionally export OpenTelemetry spans for external tracing (v2+)

### Questions

* QUESTION: should `at_ms` use `performance.now()` for monotonic time, or wall clock? (likely monotonic)
* QUESTION: how to generate stable ids for realtime events without backend ids? → `?`

---
