### docs/connectome/state_store/PATTERNS_Connectome_State_Store_Single_Source_Of_Truth_For_Events_Focus_And_Timers.md

$$$

# state_store — Patterns: Single Source of Truth for Ledger, Focus, and Timers

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
THIS:            PATTERNS_Connectome_State_Store_Single_Source_Of_Truth_For_Events_Focus_And_Timers.md (you are here)
BEHAVIORS:       ./BEHAVIORS_Connectome_State_Store_Observable_State_Consistency_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_State_Store_Atomic_Commits_For_Step_Releases_And_Realtime.md
VALIDATION:      ./VALIDATION_Connectome_State_Store_Invariants_For_Ledger_Ordering_And_Focus.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_State_Store_Code_Structure_And_Zustand_Actions.md
HEALTH:          ./HEALTH_Connectome_State_Store_Runtime_Verification_Of_Ledger_And_Timer_Correctness.md
SYNC:            ./SYNC_Connectome_State_Store_Sync_Current_State.md
$$$

### Bidirectional Contract

$$$
Before modifying this doc or the code:

1. Read ALL docs in this chain
2. Read event_model + runtime_engine chains (store is downstream)

After modifying this doc:

* Update implementation OR record mismatch in SYNC

After modifying the code:

* Update docs OR record mismatch in SYNC

Never degrade:

* atomicity of step commits
* append-only ledger semantics (within a session)
* focus correctness (one active node + one active edge)
  $$$

---

## THE PROBLEM

/connectome needs to behave like a debugger and an observability surface.

If state is scattered across components:

* edges “disappear” (recompute/resize races)
* focus highlights conflict (multiple active nodes)
* log becomes inconsistent (copy/export mismatch)
* progress widgets drift (wait timers not tied to event semantics)
* stepper invariants become untestable (no single place to observe deltas)

We need a single, agent-friendly state owner.

---

## THE PATTERN

**One store; append-only ledger; atomic release commits.**

The state_store is the canonical state authority for /connectome:

* event ledger (FlowEvents)
* active focus (node/edge + step key)
* runtime mode/speed/local pause flags
* wait progress timers (message→answer) signals
* tick cadence display signals (cron node progress)

Key insight:

> Rendering modules should be pure views over state.
> The store provides the “truthy now”.

---

## PRINCIPLES

### Principle 1: Append-only ledger per session

Within a “session”:

* ledger grows by appending events
* no mutation of past entries (immutability for audit/copy)

If “Restart” occurs:

* either clear ledger OR start a new session boundary (decision recorded in runtime_engine SYNC)

### Principle 2: Atomic commit for each release

When a step releases:

* append event
* set focus
* set current explanation sentence
* update timers (if the step starts/stops wait)
* update counters (cursor, step index)
  …all in one action.

### Principle 3: Store owns time signals, not rendering clocks

Store holds:

* “wait started at ms”
* “last answer arrived at ms”
* “nominal tick interval ms”
* “cron progress 0..1”
  Rendering reads and displays; rendering doesn’t invent semantics.

---

## DATA

| Data                  | Description                                       |
| --------------------- | ------------------------------------------------- |
| `ledger`              | array of FlowEvent (append-only per session)      |
| `active_focus`        | {active_node_id, active_edge_id, active_step_key} |
| `current_explanation` | one sentence for current step                     |
| `mode`                | stepper | realtime                                |
| `speed`               | pause | 1x | 2x | 3x                              |
| `local_pause`         | realtime local pause toggle                       |
| `cursor`              | step script index (stepper)                       |
| `wait_progress`       | {started_at_ms, value_0_1, seconds_display}       |
| `tick_display`        | {interval_ms, progress_0_1, speed_label}          |
| `health_badges`       | module -> OK/WARN/ERROR + tooltip counts          |

---

## DEPENDENCIES

| Module           | Why We Depend On It                                       |
| ---------------- | --------------------------------------------------------- |
| `event_model`    | FlowEvent type and normalization result storage           |
| `runtime_engine` | drives store commits; store should not release on its own |
| `log_panel`      | renders from ledger + current explanation                 |
| `flow_canvas`    | reads active_focus and renders highlights                 |

---

## INSPIRATIONS

* trace viewers (append-only span list)
* Redux/Zustand “single store” patterns
* debugger state machines (cursor + focus)

---

## SCOPE

### In Scope

* schema for store state
* append + focus + explanation atomic commits
* retention policy for realtime ledger (cap N or time window) as config
* copy/export support (log_panel may format, store holds the raw ledger)

### Out of Scope

* normalization (event_model)
* release authorization (runtime_engine)
* layout/rendering (flow_canvas, node_kit, edge_kit)
* backend truth (Tempo/Canon correctness)

---

## ENTRY POINTS (ACTIONS)

Store actions must be explicit and long-named.

| Action                                                             | Purpose                        |
| ------------------------------------------------------------------ | ------------------------------ |
| `commit_step_release_append_event_and_set_focus_and_explanation()` | atomic stepper release         |
| `append_realtime_event_and_update_focus_if_needed()`               | realtime ingestion (deferred)  |
| `set_mode_and_reset_buffers_if_needed()`                           | mode switch                    |
| `set_speed_and_update_nominal_tick_interval()`                     | speed selection (presentation) |
| `restart_session_clear_or_boundary()`                              | restart policy                 |
| `set_player_wait_timer_start_ms()`                                 | start wait bar                 |
| `set_player_wait_timer_stop_ms_and_reset_progress()`               | stop wait bar                  |
| `set_tick_display_progress_0_1()`                                  | cron node fill                 |

---

## DATA FLOW AND DOCKING (FLOW-BY-FLOW)

### stepper_release_atomic_commit: one release → store commit

$$$
flow:
name: stepper_release_atomic_commit
steps:
- runtime_engine releases one FlowEvent
- state_store commits: append + focus + explanation + counters + timers
- renderers re-render from store
docking_points:
- dock_store_commit_transaction (event): emitted once per commit, used by HEALTH
$$$

### realtime_ingestion_append_and_retention: append with retention (deferred)

$$$
flow:
name: realtime_ingestion_append_and_retention
steps:
- telemetry_adapter produces raw payload
- event_model normalizes → FlowEvent
- store appends, applies retention policy
docking_points:
- dock_store_retention_evictions (metric)
$$$

---

## GAPS / IDEAS / QUESTIONS

* [ ] Decide restart policy: clear ledger vs session boundary (must match runtime_engine).
* [ ] Decide retention strategy for realtime: max N events or last T seconds.
* QUESTION: Should store keep raw payload? recommended: keep only when debug toggle enabled.
* IDEA: Store can keep a lightweight derived “current tick counter” for display, but must not become a simulation owner.

---

---

### docs/connectome/state_store/BEHAVIORS_Connectome_State_Store_Observable_State_Consistency_Effects.md

$$$

# state_store — Behaviors: Observable Effects of a Single Canonical Store

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_State_Store_Single_Source_Of_Truth_For_Events_Focus_And_Timers.md
THIS:            BEHAVIORS_Connectome_State_Store_Observable_State_Consistency_Effects.md (you are here)
ALGORITHM:       ./ALGORITHM_Connectome_State_Store_Atomic_Commits_For_Step_Releases_And_Realtime.md
VALIDATION:      ./VALIDATION_Connectome_State_Store_Invariants_For_Ledger_Ordering_And_Focus.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_State_Store_Code_Structure_And_Zustand_Actions.md
HEALTH:          ./HEALTH_Connectome_State_Store_Runtime_Verification_Of_Ledger_And_Timer_Correctness.md
SYNC:            ./SYNC_Connectome_State_Store_Sync_Current_State.md
$$$

---

## BEHAVIORS

### B1: “One step” feels atomic everywhere

$$$
GIVEN:  a step is released
WHEN:   the store updates
THEN:   the diagram highlight, explanation sentence, and log entry change together
AND:    there is no intermediate state where the highlight changed but the log did not (or vice versa)
$$$

### B2: The ledger is always copyable and truthful

$$$
GIVEN:  the user presses “Copy log”
THEN:   the exported data is exactly the ledger entries in the store
AND:    the export includes stable ids and required fields (per event_model)
$$$

### B3: Focus is singular and persistent

$$$
GIVEN:  a step is released
THEN:   there is exactly one active edge and one active node focus
AND:    they remain active until the next release
$$$

### B4: Wait progress bar behaves like time-under-load, not animation

$$$
GIVEN:  a player message is “sent”
WHEN:   no answer has arrived yet
THEN:   wait progress increases up to max 4.0s
AND:    when the answer arrives, progress stops and resets (or marks completion)
$$$

### B5: Tick cron display is consistent with speed selection

$$$
GIVEN:  speed is set to pause/1x/2x/3x
THEN:   store updates nominal tick interval and tick display label
AND:    the cron node fill reflects the interval (signal only; rendering owns animation)
$$$

---

## EDGE CASES

### E1: Rapid Next clicking

$$$
GIVEN:  user clicks Next rapidly
THEN:   store commits remain ordered and consistent (no lost steps)
$$$

### E2: Out-of-order realtime events (deferred)

$$$
GIVEN:  two realtime events arrive out of order
THEN:   store preserves a stable ordering policy (arrival order or at_ms policy)
AND:    UI remains readable
$$$

---

## ANTI-BEHAVIORS

### A1: Component-local shadow ledger

$$$
MUST NOT: maintain a separate log list in a component
INSTEAD: log is derived exclusively from store.ledger
$$$

### A2: Focus ambiguity

$$$
MUST NOT: multiple active edges remain lit simultaneously (unless explicitly allowed)
INSTEAD: store.active_focus is singular
$$$

---

## INPUTS / OUTPUTS

Store is a state authority; it does not return values except selectors.

**Inputs (actions):** explicit store actions (see PATTERNS).
**Outputs:** updated state; selectors for UI.

---

## GAPS / IDEAS / QUESTIONS

* QUESTION: Should focus include “active_zone_id” (FE/BE/GRAPH/AGENTS) to improve zone highlighting?
* IDEA: Include a “session_id” so exports clearly separate restarts.

---

---

### docs/connectome/state_store/ALGORITHM_Connectome_State_Store_Atomic_Commits_For_Step_Releases_And_Realtime.md

$$$

# state_store — Algorithm: Atomic Commits for Releases, Focus, and Timers

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_State_Store_Single_Source_Of_Truth_For_Events_Focus_And_Timers.md
BEHAVIORS:       ./BEHAVIORS_Connectome_State_Store_Observable_State_Consistency_Effects.md
THIS:            ALGORITHM_Connectome_State_Store_Atomic_Commits_For_Step_Releases_And_Realtime.md (you are here)
VALIDATION:      ./VALIDATION_Connectome_State_Store_Invariants_For_Ledger_Ordering_And_Focus.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_State_Store_Code_Structure_And_Zustand_Actions.md
HEALTH:          ./HEALTH_Connectome_State_Store_Runtime_Verification_Of_Ledger_And_Timer_Correctness.md
SYNC:            ./SYNC_Connectome_State_Store_Sync_Current_State.md
$$$

---

## OVERVIEW

state_store owns:

* the append-only ledger of FlowEvents
* the active focus (node/edge/step key)
* the current explanation sentence
* mode/speed flags and time signals (wait/tick widgets)

All updates for one release must occur in a single commit to prevent visual/log desync.

---

## DATA STRUCTURES

### `ConnectomeStoreState`

$$$
ConnectomeStoreState:
session_id: string
mode: stepper|realtime
speed: pause|1x|2x|3x
local_pause: boolean
cursor: number
ledger: FlowEvent[]
active_focus:
active_node_id: string|null
active_edge_id: string|null
active_step_key: string|null
current_explanation:
sentence: string
notes: string|null
wait_progress:
started_at_ms: number|null
stopped_at_ms: number|null
max_seconds: 4.0
tick_display:
nominal_interval_ms: number|Infinity
progress_0_1: number
speed_label: string
health_badges:
[module_name]: {status: OK|WARN|ERROR|UNKNOWN, tooltip: string}
$$$

---

## ALGORITHM: `commit_step_release_append_event_and_set_focus_and_explanation(release)`

Input: `release` contains:

* `event: FlowEvent`
* `focus: {node_id, edge_id, step_key}`
* `explanation_sentence: string`
* `wait_timer_action?: start|stop|none`
* `cursor_next: number`

Steps:

1. Validate minimal shape (never throw; fill `?` if needed)
2. Append event to ledger (immutable append)
3. Set active_focus exactly to focus values
4. Set current_explanation sentence and notes
5. Apply wait timer updates:

   * start: set started_at_ms=now, stopped_at_ms=null
   * stop: set stopped_at_ms=now (or set started_at_ms=null if reset policy)
6. Update cursor to cursor_next
7. Done (one transaction)

---

## ALGORITHM: `restart_session_clear_or_boundary()`

Policy must match runtime_engine.

Option A (clear):

* new session_id
* ledger=[]
* cursor=0
* clear focus/explanation
* reset timers

Option B (boundary):

* new session_id
* preserve ledger but insert a boundary marker event (call_type=code, label="SESSION_BOUNDARY") (?)
* cursor=0
* reset focus/explanation/timers

Mark the chosen policy in SYNC once decided.

---

## ALGORITHM: `append_realtime_event_and_update_focus_if_needed(event)` (deferred)

1. Append event
2. Decide focus update policy:

   * either focus latest event always
   * or focus only if user has not pinned focus
3. Apply retention policy
4. Done

---

## ALGORITHM: wait progress computation (selector)

Given:

* started_at_ms
* now_ms
  Compute:
* elapsed_s = clamp((now-start)/1000, 0, 4.0)
* value_0_1 = elapsed_s / 4.0
* display = round(elapsed_s, 1)

Store does not “tick” this; a selector can compute on render, or a lightweight interval can update tick_display only (but must not release steps).

---

## COMPLEXITY

* append: O(1) per event
* export: O(n) over ledger
* retention: O(k) evictions (bounded)

---

## GAPS / IDEAS / QUESTIONS

* [ ] Decide focus policy in realtime mode (auto-focus newest vs pinned).
* QUESTION: Should store include a “pinned_focus” that prevents realtime from overriding focus?
* IDEA: Provide a derived selector to produce “duration color class” for the log panel to avoid duplicating rules.

---

---

### docs/connectome/state_store/VALIDATION_Connectome_State_Store_Invariants_For_Ledger_Ordering_And_Focus.md

$$$

# state_store — Validation: Invariants for Ledger, Focus, and Timers

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_State_Store_Single_Source_Of_Truth_For_Events_Focus_And_Timers.md
BEHAVIORS:       ./BEHAVIORS_Connectome_State_Store_Observable_State_Consistency_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_State_Store_Atomic_Commits_For_Step_Releases_And_Realtime.md
THIS:            VALIDATION_Connectome_State_Store_Invariants_For_Ledger_Ordering_And_Focus.md (you are here)
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_State_Store_Code_Structure_And_Zustand_Actions.md
HEALTH:          ./HEALTH_Connectome_State_Store_Runtime_Verification_Of_Ledger_And_Timer_Correctness.md
SYNC:            ./SYNC_Connectome_State_Store_Sync_Current_State.md
$$$

---

## INVARIANTS

### V1: Ledger is append-only within a session

$$$
Within a session_id:
ledger length never decreases
past entries are never mutated
$$$

### V2: Exactly one active focus

$$$
active_focus.active_node_id is one value or null
active_focus.active_edge_id is one value or null
No parallel “active set” unless explicitly designed
$$$

### V3: Atomic commit integrity

$$$
For each step release commit:
ledger appended AND focus updated AND explanation updated occur in the same commit
No observable intermediate state should exist
$$$

### V4: Wait timer boundaries are correct

$$$
If wait_progress.started_at_ms is set:
started_at_ms <= now_ms
Elapsed seconds are clamped to [0, 4.0]
Display uses 1 decimal precision
$$$

---

## PROPERTIES

### P1: Export equals ledger

$$$
Copy/export output must equal store.ledger (1:1) plus optional formatting metadata
$$$

### P2: Restart resets state consistently with selected policy

$$$
After restart:
cursor == 0
focus cleared
timers reset
session_id changes
and ledger behavior matches chosen policy (clear vs boundary)
$$$

---

## ERROR CONDITIONS

### E1: Focus mismatch

* symptom: multiple nodes/edges appear active simultaneously due to store state
* severity: ERROR

### E2: Ledger mutation

* symptom: existing ledger event changes after append
* severity: ERROR

---

## HEALTH COVERAGE

| Validation | Health Indicator                   |
| ---------- | ---------------------------------- |
| V1         | store_ledger_append_only_integrity |
| V2         | store_single_focus_integrity       |
| V3         | store_atomic_commit_integrity      |
| V4         | store_wait_timer_clamp_integrity   |
| P1         | store_export_equals_ledger         |
| P2         | store_restart_policy_consistency   |

---

## VERIFICATION PROCEDURE

### Manual Checklist

$$$
[ ] Click Next once → log + focus + explanation change together
[ ] Click Next again → previous entry unchanged, ledger grows by 1
[ ] Click Restart → session_id changes, cursor=0, focus cleared
[ ] Trigger wait timer start/stop → progress clamps to 4.0s and shows 1 decimal
[ ] Copy log → export equals visible ledger count
$$$

### Automated

$$$
pnpm connectome:health state_store
$$$

---

## SYNC STATUS

$$$
LAST_VERIFIED: 2025-12-20
VERIFIED_AGAINST:
impl: ?
health: ?
RESULT:
V1: NOT RUN
V2: NOT RUN
V3: NOT RUN
V4: NOT RUN
$$$

---

## GAPS / IDEAS / QUESTIONS

* QUESTION: do we need a “transaction id” recorded per commit for debugging atomicity? (nice-to-have)
* IDEA: ledger entries can include `arrival_index` to guarantee ordering even with same timestamp

---

---

### docs/connectome/state_store/HEALTH_Connectome_State_Store_Runtime_Verification_Of_Ledger_And_Timer_Correctness.md

$$$

# state_store — Health: Verification Mechanics and Coverage

STATUS: DRAFT
CREATED: 2025-12-20
$$$

---

## PURPOSE OF THIS FILE

This HEALTH file ensures the state_store makes /connectome trustworthy:

* ledger append-only
* single active focus
* atomic commit behavior
* wait timer clamping correctness
* export equals ledger

It does not validate rendering aesthetics or backend correctness.

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_State_Store_Single_Source_Of_Truth_For_Events_Focus_And_Timers.md
BEHAVIORS:       ./BEHAVIORS_Connectome_State_Store_Observable_State_Consistency_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_State_Store_Atomic_Commits_For_Step_Releases_And_Realtime.md
VALIDATION:      ./VALIDATION_Connectome_State_Store_Invariants_For_Ledger_Ordering_And_Focus.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_State_Store_Code_Structure_And_Zustand_Actions.md
THIS:            HEALTH_Connectome_State_Store_Runtime_Verification_Of_Ledger_And_Timer_Correctness.md
SYNC:            ./SYNC_Connectome_State_Store_Sync_Current_State.md

IMPL:            ? (planned) scripts/connectome/health/state_store_health_check_runner.ts
$$$

---

## FLOWS ANALYSIS (TRIGGERS + FREQUENCY)

$$$
flows_analysis:

* flow_id: store_stepper_atomic_commit
  purpose: Prevent desync between highlight, explanation, and log.
  triggers:

  * type: manual
    source: runtime_engine Next click
    frequency:
    expected_rate: "human driven"
    peak_rate: "rapid clicking"
    risks:
  * "partial commits"
  * "focus not updated"
  * "ledger mutation"
    notes: "Primary v1 risk: UI feels glitchy (links disappear, focus wrong)."

* flow_id: store_wait_timer_progress
  purpose: Ensure progress bar semantics trustworthy.
  triggers:

  * type: event
    source: runtime_engine start_wait / stop_wait
    frequency:
    expected_rate: "per player message"
    peak_rate: "rare"
    risks:
  * "progress exceeds 4.0s"
  * "display precision wrong"
    $$$

---

## HEALTH INDICATORS SELECTED

$$$
health_indicators:

* name: store_ledger_append_only_integrity
  flow_id: store_stepper_atomic_commit
  priority: high
  rationale: "Auditability and copy/export depend on this."

* name: store_single_focus_integrity
  flow_id: store_stepper_atomic_commit
  priority: high
  rationale: "Prevents multi-glow confusion."

* name: store_atomic_commit_integrity
  flow_id: store_stepper_atomic_commit
  priority: high
  rationale: "Prevents UI/log mismatch and disappearing edges."

* name: store_wait_timer_clamp_integrity
  flow_id: store_wait_timer_progress
  priority: med
  rationale: "Progress bar must be truthful and bounded."

* name: store_export_equals_ledger
  flow_id: store_stepper_atomic_commit
  priority: high
  rationale: "Copy log must be exact."
  $$$

---

## CHECKER INDEX

$$$
checkers:

* name: health_check_ledger_is_append_only
  purpose: "Detect any mutation or deletion within a session_id."
  status: pending
  priority: high

* name: health_check_single_active_focus
  purpose: "Ensure focus is singular and stable until next release."
  status: pending
  priority: high

* name: health_check_atomic_commit_updates_all_fields
  purpose: "Ensure ledger+focus+explanation update together."
  status: pending
  priority: high

* name: health_check_wait_timer_clamps_to_max_4_seconds
  purpose: "Ensure wait timer never exceeds 4.0s and uses 0.1 display precision."
  status: pending
  priority: med

* name: health_check_export_equals_ledger
  purpose: "Exported JSONL or text equals ledger contents."
  status: pending
  priority: high
  $$$

---

## HOW TO RUN

$$$
pnpm connectome:health state_store
pnpm connectome:health state_store --checker health_check_atomic_commit_updates_all_fields
$$$

---

## KNOWN GAPS

* [ ] Dock locations are unknown until implementation exists (file:line = ?)
* [ ] Restart policy not finalized; checks must branch by policy

---

## GAPS / IDEAS / QUESTIONS

* IDEA: add “commit_id” incremented per atomic commit to make HEALTH checks trivial.
* QUESTION: should export include session_id header? recommended: yes.

---

---

### docs/connectome/state_store/SYNC_Connectome_State_Store_Sync_Current_State.md

$$$

# state_store — Sync: Current State

LAST_UPDATED: 2025-12-20
UPDATED_BY: Marco "Salthand" (agent)
STATUS: DESIGNING
$$$

---

## MATURITY

**Canonical (v1 intent):**

* one store owns ledger + focus + timers + explanation
* atomic commit per step release
* append-only ledger within a session

**In design:**

* restart policy (clear vs boundary)
* realtime retention policy (max N vs time window)

**Deferred:**

* realtime ingestion details
* pinned focus behavior

---

## CURRENT STATE

state_store docs are defined; implementation does not exist yet. This module is the intended single authority to prevent “links disappear” and “log/explain drift” bugs.

---

## RECENT CHANGES

### 2025-12-20: Initialized state_store chain docs

* Defined append-only ledger + atomic commit semantics
* Defined wait timer and tick display signals as store-owned semantics

---

## KNOWN ISSUES

### Restart policy unresolved

* Issue: whether restart clears ledger or starts a new session boundary
* Impact: affects export format and determinism
* Current handling: documented as A/B, must be decided and locked

---

## HANDOFF: FOR AGENTS

* Implement in Zustand with explicit long action names
* Ensure each Next release is one atomic action (append+focus+explain)
* Do not allow components to keep shadow copies of ledger/focus

---

## HANDOFF: FOR HUMAN

* Please decide: Restart clears ledger OR creates a boundary (prefer boundary for auditability)
* Please decide retention policy for realtime mode (cap N vs time window)

---

## TODO

* [ ] Implement store state + actions with long descriptive filenames
* [ ] Implement export function used by log_panel
* [ ] Add state_store health runner (pending)

Run:

$$$
pnpm connectome:health state_store
$$$

---

---

### docs/connectome/state_store/IMPLEMENTATION_Connectome_State_Store_Code_Structure_And_Zustand_Actions.md

$$$

# state_store — Implementation: Code Architecture and Structure

STATUS: DRAFT
CREATED: 2025-12-20
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_State_Store_Single_Source_Of_Truth_For_Events_Focus_And_Timers.md
BEHAVIORS:       ./BEHAVIORS_Connectome_State_Store_Observable_State_Consistency_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_State_Store_Atomic_Commits_For_Step_Releases_And_Realtime.md
VALIDATION:      ./VALIDATION_Connectome_State_Store_Invariants_For_Ledger_Ordering_And_Focus.md
THIS:            IMPLEMENTATION_Connectome_State_Store_Code_Structure_And_Zustand_Actions.md
HEALTH:          ./HEALTH_Connectome_State_Store_Runtime_Verification_Of_Ledger_And_Timer_Correctness.md
SYNC:            ./SYNC_Connectome_State_Store_Sync_Current_State.md

IMPL:            app/connectome/lib/zustand_connectome_state_store_with_atomic_commit_actions.ts (PROPOSED)
$$$

---

## CODE STRUCTURE

$$$
app/
└── connectome/
├── lib/
│   ├── zustand_connectome_state_store_with_atomic_commit_actions.ts
│   ├── connectome_session_boundary_and_restart_policy_controller.ts
│   ├── connectome_wait_timer_progress_and_tick_display_signal_selectors.ts
│   └── connectome_export_jsonl_and_text_log_serializer.ts
$$$

### File Responsibilities

| File                                                                  | Responsibility                   | Key Exports                                       |
| --------------------------------------------------------------------- | -------------------------------- | ------------------------------------------------- |
| `zustand_connectome_state_store_with_atomic_commit_actions.ts`        | store state + long-named actions | `useConnectomeStore`                              |
| `connectome_session_boundary_and_restart_policy_controller.ts`        | implements restart policy A/B    | `restart_session_*`                               |
| `connectome_wait_timer_progress_and_tick_display_signal_selectors.ts` | selectors for wait/tick widgets  | `selectWaitProgress`, `selectTickDisplay`         |
| `connectome_export_jsonl_and_text_log_serializer.ts`                  | stable copy/export               | `serializeLedgerToJsonl`, `serializeLedgerToText` |

---

## DESIGN PATTERNS

* Single store authority (Zustand)
* atomic commit action for each release
* pure selectors for derived time values (avoid scattered timers)

---

## ENTRY POINTS

| Entry Point                                                        | Trigger                     |
| ------------------------------------------------------------------ | --------------------------- |
| `commit_step_release_append_event_and_set_focus_and_explanation()` | runtime_engine step release |
| `restart_session_clear_or_boundary()`                              | user Restart                |
| `serializeLedgerToJsonl()`                                         | Copy/export button          |

---

## DATA FLOW AND DOCKING

### store_atomic_commit: runtime release → store update

$$$
flow:
name: store_atomic_commit
steps:
- runtime_engine calls commit action with {event, focus, explanation, timer actions}
- store mutates ledger + focus + explanation in one transaction
docking_points:
- dock_store_commit_action_invoked (event): for HEALTH
$$$

---

## STATE MANAGEMENT

State is the product here.

* keep ledger immutable by copying array on append
* keep focus singular
* keep explanation as one sentence

---

## CONFIGURATION

| Config                 | Default | Notes                             |
| ---------------------- | ------- | --------------------------------- |
| `MAX_WAIT_SECONDS`     | 4.0     | progress cap                      |
| `RETENTION_MAX_EVENTS` | ?       | realtime retention cap (deferred) |
| `RESTART_POLICY`       | ?       | clear vs boundary                 |

---

## BIDIRECTIONAL LINKS

### Code → Docs

* store file header references docs/connectome/state_store/*

### Docs → Code

* validation invariants are implemented as store health checks

---

## GAPS / IDEAS / QUESTIONS

* [ ] Decide RESTART_POLICY and lock it (docs + code)
* [ ] Decide retention cap for realtime mode
