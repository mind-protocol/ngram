### docs/connectome/telemetry_adapter/PATTERNS_Connectome_Telemetry_Adapter_Sse_To_FlowEvent_Normalization_Docking_Patterns.md

$$$

# telemetry_adapter — Patterns: SSE-to-FlowEvent Docking for Realtime Connectome Playback

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
THIS:            PATTERNS_Connectome_Telemetry_Adapter_Sse_To_FlowEvent_Normalization_Docking_Patterns.md (you are here)
BEHAVIORS:       ./BEHAVIORS_Connectome_Telemetry_Adapter_Realtime_Ingestion_Buffering_And_Backpressure_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Telemetry_Adapter_Sse_Subscription_Event_Parsing_And_Raw_Event_Emission.md
VALIDATION:      ./VALIDATION_Connectome_Telemetry_Adapter_Invariants_For_No_Dropped_Events_And_Stable_Order.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Telemetry_Adapter_Code_Structure_For_Sse_And_Snapshot_Docking.md
HEALTH:          ./HEALTH_Connectome_Telemetry_Adapter_Runtime_Verification_Of_Stream_Integrity_And_Buffer_Bounds.md
SYNC:            ./SYNC_Connectome_Telemetry_Adapter_Sync_Current_State.md
$$$

---

## THE PROBLEM

/connectome needs a realtime mode that is truthful:

* consume backend SSE streams (moments, tempo, weights, etc.)
* map each inbound SSE payload to a canonical FlowEvent (event_model)
* preserve order and avoid silent drops
* provide local pause + buffering semantics (runtime_engine)
* provide health signals (rate, drops, parse failures, buffer size)

Without a telemetry_adapter:

* realtime mode becomes “random UI animation”
* payload parsing spreads across components and drifts
* unknown SSE events vanish silently
* debugging regressions are impossible to audit
* the connectome cannot become a real dashboard for the running system

---

## THE PATTERN

**Single ingress boundary: SSE → RawTelemetryEnvelope → FlowEvent.**

telemetry_adapter performs only ingress concerns:

* subscribe to SSE streams
* parse event name + JSON payload
* annotate metadata (received time, stream name)
* output raw envelopes that event_model can normalize deterministically

Key insight:

> Realtime is not “another UI mode.”
> Realtime is an ingestion pipeline. Treat it like one: one dock, one normalization boundary.

---

## PRINCIPLES

### Principle 1: One-way truth stream, no UI inference

telemetry_adapter must not infer semantics the event_model already defines.

* it preserves what arrived
* it annotates where it came from
* it never “fixes” payloads except minimal parse normalization

### Principle 2: Unknown events are preserved, never dropped

Any unrecognized SSE event name:

* still becomes a raw envelope
* becomes a FlowEvent with notes="?" after normalization
* appears in the unified log

### Principle 3: Buffering is explicit and bounded

Realtime pause is a local UI control:

* when locally paused, events are buffered
* buffers must be bounded by retention policy (size/time)
* overflow policy must be explicit (drop oldest with WARN, or stop ingestion) → `?`

### Principle 4: Order is stable and auditable

Ordering policy must be explicit:

* default: arrival order (received_at_ms + arrival_index)
* do not attempt to reorder by backend timestamps unless proven necessary → `?`

---

## DATA

| Data                   | Description                                  |
| ---------------------- | -------------------------------------------- |
| `SseFrame`             | raw SSE frame: {event_name, data_text}       |
| `RawTelemetryEnvelope` | parsed JSON + stream metadata + receipt time |
| `arrival_index`        | monotonic counter for stable ordering        |
| `buffer`               | bounded queue used when locally paused       |

---

## DEPENDENCIES

| Module           | Why                                                             |
| ---------------- | --------------------------------------------------------------- |
| `event_model`    | telemetry_adapter outputs raw envelopes; event_model normalizes |
| `runtime_engine` | realtime mode attach/detach, local pause gating                 |
| `state_store`    | buffer counters and “telemetry connected” state signals         |
| `backend_docks`  | optional snapshot endpoints (reserved, may stay `?`)            |

---

## INSPIRATIONS

* Observability ingestion pipelines
* EventSource/SSE clients in dashboards
* Trace collectors (preserve raw, normalize later)

---

## SCOPE

### In Scope (v1)

* SSE subscription management (connect/disconnect/retry)
* parse SSE frames into raw telemetry envelopes
* arrival ordering metadata
* expose connection state signals (connected/disconnected/error)
* minimal buffering when locally paused (bounded)

### Out of Scope (v1)

* full backend schema enforcement (event_model + validation own semantics)
* rendering and animation (flow_canvas/edge_kit/node_kit)
* stepper sequencing (runtime_engine)
* creation of new backend endpoints (backend_docks, reserved)

---

## GAPS / IDEAS / QUESTIONS

* [ ] Confirm actual SSE endpoints and event names used by the backend → `?`
* QUESTION: one SSE connection or multiple (moments + tempo + weights)? (likely multiple, unified into one envelope stream)
* IDEA: add a “telemetry source selector” UI (dev vs prod) later

---

---

### docs/connectome/telemetry_adapter/BEHAVIORS_Connectome_Telemetry_Adapter_Realtime_Ingestion_Buffering_And_Backpressure_Effects.md

$$$

# telemetry_adapter — Behaviors: Realtime Ingestion, Buffering, and Backpressure Effects

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Telemetry_Adapter_Sse_To_FlowEvent_Normalization_Docking_Patterns.md
THIS:            BEHAVIORS_Connectome_Telemetry_Adapter_Realtime_Ingestion_Buffering_And_Backpressure_Effects.md (you are here)
ALGORITHM:       ./ALGORITHM_Connectome_Telemetry_Adapter_Sse_Subscription_Event_Parsing_And_Raw_Event_Emission.md
VALIDATION:      ./VALIDATION_Connectome_Telemetry_Adapter_Invariants_For_No_Dropped_Events_And_Stable_Order.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Telemetry_Adapter_Code_Structure_For_Sse_And_Snapshot_Docking.md
HEALTH:          ./HEALTH_Connectome_Telemetry_Adapter_Runtime_Verification_Of_Stream_Integrity_And_Buffer_Bounds.md
SYNC:            ./SYNC_Connectome_Telemetry_Adapter_Sync_Current_State.md
$$$

---

## BEHAVIORS

### B1: Realtime mode visibly connects or fails

$$$
GIVEN:  user switches to realtime mode
THEN:   telemetry_adapter reports connection state (connected / connecting / error)
AND:    the UI can show a clear badge
$$$

### B2: Every SSE frame becomes a logged event (even if unknown)

$$$
GIVEN:  an SSE event arrives (recognized or not)
THEN:   telemetry_adapter produces a raw envelope
AND:    event_model produces a FlowEvent (notes="?" when unknown)
AND:    it appears in the ledger log
$$$

### B3: Local pause buffers rather than losing information (bounded)

$$$
GIVEN:  mode=realtime and local_pause=true
WHEN:   events arrive
THEN:   they are buffered
AND:    buffer size is visible in UI/health
AND:    buffer does not grow unbounded (retention policy applies)
$$$

### B4: Resume drains in a stable order

$$$
GIVEN:  local_pause flips false
THEN:   buffered events drain in stable ordering policy (arrival order)
AND:    the UI does not reorder unexpectedly
$$$

### B5: Backpressure signals are available

$$$
GIVEN:  ingestion rate becomes high
THEN:   telemetry_adapter exposes rate metrics and parse errors
AND:    health checks can alert on overload or drops
$$$

---

## ANTI-BEHAVIORS

### A1: Silent drops

$$$
MUST NOT: discard unknown or malformed events without logging
INSTEAD: preserve with notes="?" and raw_payload (if debug enabled)
$$$

### A2: UI parses SSE directly

$$$
MUST NOT: parse EventSource payloads in components
INSTEAD: telemetry_adapter centralizes parsing and emits envelopes
$$$

---

## EDGE CASES

### E1: Malformed JSON payload

$$$
GIVEN:  SSE data is not valid JSON
THEN:   telemetry_adapter creates an envelope with data_text preserved
AND:    marks parse_error and notes="?"
$$$

### E2: Disconnect/reconnect

$$$
GIVEN:  SSE connection drops
THEN:   telemetry_adapter retries with backoff
AND:    connection status updates accordingly
$$$

---

## GAPS / IDEAS / QUESTIONS

* QUESTION: Should reconnect reset arrival_index or continue monotonic? (prefer continue per session)
* IDEA: allow “pause but still show connection status” (buffering continues)

---

---

### docs/connectome/telemetry_adapter/ALGORITHM_Connectome_Telemetry_Adapter_Sse_Subscription_Event_Parsing_And_Raw_Event_Emission.md

$$$

# telemetry_adapter — Algorithm: SSE Subscribe, Parse, Envelope, Emit

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Telemetry_Adapter_Sse_To_FlowEvent_Normalization_Docking_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Telemetry_Adapter_Realtime_Ingestion_Buffering_And_Backpressure_Effects.md
THIS:            ALGORITHM_Connectome_Telemetry_Adapter_Sse_Subscription_Event_Parsing_And_Raw_Event_Emission.md (you are here)
VALIDATION:      ./VALIDATION_Connectome_Telemetry_Adapter_Invariants_For_No_Dropped_Events_And_Stable_Order.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Telemetry_Adapter_Code_Structure_For_Sse_And_Snapshot_Docking.md
HEALTH:          ./HEALTH_Connectome_Telemetry_Adapter_Runtime_Verification_Of_Stream_Integrity_And_Buffer_Bounds.md
SYNC:            ./SYNC_Connectome_Telemetry_Adapter_Sync_Current_State.md
$$$

---

## DATA STRUCTURES

### `RawTelemetryEnvelope`

$$$
RawTelemetryEnvelope:
envelope_id: string
received_at_ms: number
arrival_index: number
stream_id: string              # e.g. "moments" | "tempo" | "weights" | "unknown"
sse_event_name: string         # e.g. "moment_spoken" | "speed_changed" | "?"
data_text: string              # raw data string from SSE
parsed_json: object|null
parse_error: string|null
notes: string|null
$$$

---

## ALGORITHM: `connect_to_sse_stream(stream_config)`

1. Set connection_state = connecting
2. Create EventSource(url)
3. Attach handlers:

* onopen → connection_state=connected
* onerror → connection_state=error; schedule retry (backoff)
* addEventListener(event_name) for known names if available else default message handler → `?`

4. Return subscription handle with `close()`

---

## ALGORITHM: `on_sse_message(frame) → RawTelemetryEnvelope`

Input: SSE frame provides:

* event_name (may be empty depending on browser API path) → `?`
* data_text

Steps:

1. arrival_index += 1
2. received_at_ms = performance.now() (monotonic preferred)
3. Attempt JSON parse:

* if parse ok: parsed_json=object
* else: parsed_json=null, parse_error=string, notes="?"

4. Create envelope_id:

* `env:${stream_id}:${arrival_index}`

5. Emit envelope to runtime_engine (or to a callback) for normalization

---

## ALGORITHM: local pause buffering gate (owned jointly with runtime_engine)

telemetry_adapter should not decide focus; it only gates envelopes.

Option A (preferred): telemetry_adapter always emits envelopes; runtime_engine buffers based on local_pause.
Option B: telemetry_adapter buffers internally when local_pause true.

V1 recommendation:

* Option A (runtime_engine/store own buffering), telemetry_adapter stays stateless.
* telemetry_adapter still exposes connection/rate metrics.

Mark chosen option in SYNC once decided.

---

## ALGORITHM: rate estimation (health signal)

Maintain a small sliding window:

* count envelopes in last 1s and 10s
* compute events_per_second estimate
* expose metric for health badges

---

## COMPLEXITY

* parse: O(size of data_text)
* per event overhead O(1)
* rate window bounded

---

## GAPS / IDEAS / QUESTIONS

* QUESTION: Do we subscribe via named SSE events (preferred) or use default onmessage? depends on backend format → `?`
* IDEA: unify multiple SSE sources into one combined envelope stream for the runtime engine.

---

---

### docs/connectome/telemetry_adapter/VALIDATION_Connectome_Telemetry_Adapter_Invariants_For_No_Dropped_Events_And_Stable_Order.md

$$$

# telemetry_adapter — Validation: Invariants for Stream Integrity, Ordering, and No Silent Drops

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Telemetry_Adapter_Sse_To_FlowEvent_Normalization_Docking_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Telemetry_Adapter_Realtime_Ingestion_Buffering_And_Backpressure_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Telemetry_Adapter_Sse_Subscription_Event_Parsing_And_Raw_Event_Emission.md
THIS:            VALIDATION_Connectome_Telemetry_Adapter_Invariants_For_No_Dropped_Events_And_Stable_Order.md (you are here)
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Telemetry_Adapter_Code_Structure_For_Sse_And_Snapshot_Docking.md
HEALTH:          ./HEALTH_Connectome_Telemetry_Adapter_Runtime_Verification_Of_Stream_Integrity_And_Buffer_Bounds.md
SYNC:            ./SYNC_Connectome_Telemetry_Adapter_Sync_Current_State.md
$$$

---

## INVARIANTS

### V1: Every SSE frame produces an envelope

$$$
For each received SSE frame:
exactly one RawTelemetryEnvelope is emitted
(even if parsing fails)
$$$

### V2: Ordering is stable

$$$
arrival_index is strictly increasing within a session
Envelopes are emitted in arrival_index order
$$$

### V3: Parse failures are explicit

$$$
If JSON parse fails:
envelope.parse_error is set
envelope.parsed_json is null
envelope.notes includes "?"
$$$

### V4: Connection state is explicit

$$$
telemetry_adapter maintains a visible connection_state:
connecting|connected|error|disconnected
$$$

### V5: No unbounded buffering (if adapter buffers internally)

$$$
If telemetry_adapter buffers:
buffer length is capped by configured retention policy
overflow behavior is explicit (WARN) and counted
$$$

(If buffering is in runtime_engine/state_store, then telemetry_adapter must still expose rate and error metrics.)

---

## ERROR CONDITIONS

### E1: Silent drop detected

* severity: ERROR
* meaning: realtime mode cannot be trusted

### E2: Envelope ordering violation

* severity: ERROR
* meaning: log replay becomes incoherent

---

## HEALTH COVERAGE

| Validation | Health Indicator                                 |
| ---------- | ------------------------------------------------ |
| V1         | telemetry_envelope_emission_integrity            |
| V2         | telemetry_arrival_order_integrity                |
| V3         | telemetry_parse_failure_visibility               |
| V4         | telemetry_connection_state_integrity             |
| V5         | telemetry_buffer_bound_integrity (if applicable) |

---

## VERIFICATION PROCEDURE

### Manual

$$$
[ ] Turn on realtime → see connecting→connected
[ ] Inject malformed SSE payload → see parse_error and “?” in log
[ ] Disconnect network → see error state and retry behavior
$$$

### Automated

$$$
pnpm connectome:health telemetry_adapter
$$$

---

## GAPS / IDEAS / QUESTIONS

* QUESTION: Where does “session” boundary live for arrival_index? (store session_id vs adapter local) → `?`

---

---

### docs/connectome/telemetry_adapter/HEALTH_Connectome_Telemetry_Adapter_Runtime_Verification_Of_Stream_Integrity_And_Buffer_Bounds.md

$$$

# telemetry_adapter — Health: Stream Integrity, Parse Errors, Rate, and Buffer Bounds

STATUS: DRAFT
CREATED: 2025-12-20
$$$

---

## PURPOSE OF THIS FILE

telemetry_adapter HEALTH ensures realtime ingestion stays trustworthy:

* no silent drops (every SSE frame becomes an envelope)
* parse failures are visible and counted
* connection state transitions are visible
* event rate and buffering are monitored (overload signals)

This does not validate backend semantics (Tempo/Canon); it validates ingestion integrity only.

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Telemetry_Adapter_Sse_To_FlowEvent_Normalization_Docking_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Telemetry_Adapter_Realtime_Ingestion_Buffering_And_Backpressure_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Telemetry_Adapter_Sse_Subscription_Event_Parsing_And_Raw_Event_Emission.md
VALIDATION:      ./VALIDATION_Connectome_Telemetry_Adapter_Invariants_For_No_Dropped_Events_And_Stable_Order.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Telemetry_Adapter_Code_Structure_For_Sse_And_Snapshot_Docking.md
THIS:            HEALTH_Connectome_Telemetry_Adapter_Runtime_Verification_Of_Stream_Integrity_And_Buffer_Bounds.md
SYNC:            ./SYNC_Connectome_Telemetry_Adapter_Sync_Current_State.md

IMPL:            ? scripts/connectome/health/telemetry_adapter_health_check_runner.ts
$$$

---

## FLOWS ANALYSIS (TRIGGERS + FREQUENCY)

$$$
flows_analysis:

* flow_id: telemetry_sse_frame_ingestion
  purpose: Ensure no drops and visible parse errors.
  triggers:

  * type: stream
    source: EventSource (browser)
    frequency:
    expected_rate: "?/s (depends on backend)"
    peak_rate: "?/s"
    burst_behavior: "possible bursts during fast tempo"
    risks:
  * "silent drops"
  * "parse errors hidden"
  * "order drift"
    notes: "Rates unknown until backend stream observed."

* flow_id: telemetry_connection_lifecycle
  purpose: Ensure status is visible during connect/retry.
  triggers:

  * type: event
    source: EventSource open/error
    frequency:
    expected_rate: "rare"
    risks:
  * "stuck connecting"
  * "no retry"
    $$$

---

## HEALTH INDICATORS SELECTED

$$$
health_indicators:

* name: telemetry_envelope_emission_integrity
  flow_id: telemetry_sse_frame_ingestion
  priority: high
  rationale: "Without this, realtime cannot be trusted."

* name: telemetry_parse_failure_visibility
  flow_id: telemetry_sse_frame_ingestion
  priority: high
  rationale: "Malformed payloads must not vanish."

* name: telemetry_arrival_order_integrity
  flow_id: telemetry_sse_frame_ingestion
  priority: high
  rationale: "Out-of-order makes tracing unusable."

* name: telemetry_connection_state_integrity
  flow_id: telemetry_connection_lifecycle
  priority: med
  rationale: "Operators must know whether telemetry is real."
  $$$

---

## CHECKER INDEX

$$$
checkers:

* name: health_check_every_sse_frame_emits_one_envelope
  purpose: "VALIDATION V1"
  status: pending
  priority: high

* name: health_check_arrival_index_monotonic
  purpose: "VALIDATION V2"
  status: pending
  priority: high

* name: health_check_parse_errors_counted_and_exposed
  purpose: "VALIDATION V3"
  status: pending
  priority: high

* name: health_check_connection_state_transitions_visible
  purpose: "VALIDATION V4"
  status: pending
  priority: med
  $$$

---

## HOW TO RUN

$$$
pnpm connectome:health telemetry_adapter
$$$

---

## KNOWN GAPS

* [ ] needs a harness to simulate SSE frames in dev/test
* [ ] actual backend event list unknown, so mapping is partially `?`

---

## GAPS / IDEAS / QUESTIONS

* IDEA: Provide a built-in “mock telemetry generator” for health checks (no backend required).
* QUESTION: Should telemetry_adapter expose a “schema_version” from backend docks? (reserved)

---

---

### docs/connectome/telemetry_adapter/SYNC_Connectome_Telemetry_Adapter_Sync_Current_State.md

$$$

# telemetry_adapter — Sync: Current State

LAST_UPDATED: 2025-12-20
UPDATED_BY: Marco "Salthand" (agent)
STATUS: RESERVED (V1 DEFERRED)
$$$

---

## MATURITY

**Canonical (v1 intent):**

* telemetry_adapter is the single ingress for realtime
* SSE frames become envelopes; unknowns preserved as “?”
* connection state and parse errors are visible signals

**Deferred in v1:**

* exact SSE endpoint list and event names
* buffering ownership (adapter vs runtime_engine)
* retention policy for realtime bursts

---

## CURRENT STATE

This module is reserved and documented, but implementation is deferred until:

* the stepper view is stable and trusted
* we confirm backend SSE contracts
* we decide buffering ownership policy

---

## TODO

* [ ] Confirm backend SSE endpoints and event names (moments/tempo/weights/…)
* [ ] Implement EventSource wrapper with connection state and parsing
* [ ] Emit RawTelemetryEnvelope objects to runtime_engine
* [ ] Add health harness with mock SSE generator

Run:

$$$
pnpm connectome:health telemetry_adapter
$$$

---

---

### docs/connectome/telemetry_adapter/IMPLEMENTATION_Connectome_Telemetry_Adapter_Code_Structure_For_Sse_And_Snapshot_Docking.md

$$$

# telemetry_adapter — Implementation: Code Architecture and Structure

STATUS: DRAFT
CREATED: 2025-12-20
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Telemetry_Adapter_Sse_To_FlowEvent_Normalization_Docking_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Telemetry_Adapter_Realtime_Ingestion_Buffering_And_Backpressure_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Telemetry_Adapter_Sse_Subscription_Event_Parsing_And_Raw_Event_Emission.md
VALIDATION:      ./VALIDATION_Connectome_Telemetry_Adapter_Invariants_For_No_Dropped_Events_And_Stable_Order.md
THIS:            IMPLEMENTATION_Connectome_Telemetry_Adapter_Code_Structure_For_Sse_And_Snapshot_Docking.md
HEALTH:          ./HEALTH_Connectome_Telemetry_Adapter_Runtime_Verification_Of_Stream_Integrity_And_Buffer_Bounds.md
SYNC:            ./SYNC_Connectome_Telemetry_Adapter_Sync_Current_State.md

IMPL:            app/connectome/lib/sse_telemetry_eventsource_adapter_with_envelope_emission.ts (PROPOSED)
$$$

---

## CODE STRUCTURE

$$$
app/
└── connectome/
├── lib/
│   ├── sse_telemetry_eventsource_adapter_with_envelope_emission.ts
│   ├── telemetry_envelope_parser_and_json_decode_with_error_preservation.ts
│   ├── telemetry_connection_state_machine_with_retry_backoff.ts
│   ├── telemetry_arrival_index_and_rate_estimation_window.ts
│   └── telemetry_stream_configuration_for_connectome_sources.ts
$$$

### File Responsibilities

| File                                                                   | Responsibility                       | Key Exports                                        |
| ---------------------------------------------------------------------- | ------------------------------------ | -------------------------------------------------- |
| `sse_telemetry_eventsource_adapter_with_envelope_emission.ts`          | creates EventSource, emits envelopes | `attachTelemetryStreams`, `detachTelemetryStreams` |
| `telemetry_envelope_parser_and_json_decode_with_error_preservation.ts` | parse JSON with explicit errors      | `parseEnvelopeDataText`                            |
| `telemetry_connection_state_machine_with_retry_backoff.ts`             | retry/backoff and status             | `ConnectionStateMachine`                           |
| `telemetry_arrival_index_and_rate_estimation_window.ts`                | monotonic ordering + rate            | `ArrivalIndex`, `RateWindow`                       |
| `telemetry_stream_configuration_for_connectome_sources.ts`             | list of stream urls/names            | `STREAM_CONFIGS` (placeholder `?`)                 |

---

## ENTRY POINTS

| Entry Point                          | Trigger                |
| ------------------------------------ | ---------------------- |
| `attachTelemetryStreams(onEnvelope)` | entering realtime mode |
| `detachTelemetryStreams()`           | leaving realtime mode  |
| `onEnvelope(envelope)`               | per SSE frame          |

---

## DATA FLOW AND DOCKING

$$$
SSE EventSource frame
→ telemetry_adapter parses to RawTelemetryEnvelope
→ runtime_engine (realtime) receives envelope
→ event_model.normalize_flow_event(envelope)
→ state_store append + focus policy
→ flow_canvas + log_panel render
$$$

---

## CONFIGURATION

| Config                | Default | Notes                             |
| --------------------- | ------- | --------------------------------- |
| `RETRY_BACKOFF_MS`    | ?       | exponential backoff               |
| `STREAM_CONFIGS`      | ?       | endpoints and event names unknown |
| `STORE_RAW_DATA_TEXT` | true    | preserve raw                      |
| `STORE_PARSED_JSON`   | true    | if parse succeeds                 |

---

## BIDIRECTIONAL LINKS

* adapter source files include doc pointers to docs/connectome/telemetry_adapter/*
* update SYNC when backend stream contracts become known

---

## GAPS / IDEAS / QUESTIONS

* QUESTION: Do we need authentication headers for SSE? (browser EventSource limitations) → `?`
* IDEA: If SSE auth is hard, switch to fetch-stream polyfill (but that affects implementation and must be documented).
