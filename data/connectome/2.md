### docs/connectome/runtime_engine/PATTERNS_Connectome_Runtime_Engine_Stepper_And_Realtime_Traversal_Control_Patterns.md

$$$

# runtime_engine — Patterns: Stepper-Gated Traversal and Realtime Playback Control

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
THIS:            PATTERNS_Connectome_Runtime_Engine_Stepper_And_Realtime_Traversal_Control_Patterns.md (you are here)
BEHAVIORS:       ./BEHAVIORS_Connectome_Runtime_Engine_User_Controlled_Traversal_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Runtime_Engine_Step_Release_And_Realtime_Scheduling.md
VALIDATION:      ./VALIDATION_Connectome_Runtime_Engine_Invariants_For_Stepper_And_Realtime.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Runtime_Engine_Code_Structure_And_Control_Surface.md
HEALTH:          ./HEALTH_Connectome_Runtime_Engine_Runtime_Verification_Of_Pacing_And_Order.md
SYNC:            ./SYNC_Connectome_Runtime_Engine_Sync_Current_State.md
$$$

### Bidirectional Contract

$$$
Before modifying this doc or the code:

1. Read ALL docs in this chain
2. Read event_model chain (runtime_engine depends on FlowEvent)

After modifying this doc:

* Update implementation OR record mismatch in SYNC

After modifying the code:

* Update docs OR record mismatch in SYNC

Never degrade:

* Stepper determinism
* “One step per Next click” guarantee
* No uncontrolled autoplay in stepper mode
  $$$

---

## THE PROBLEM

/connectome has two incompatible “truth rhythms” unless we enforce them explicitly:

1. **Stepper mode:** user advances *exactly one function/event* per Next click.
2. **Realtime mode:** system advances as events arrive (SSE / timers), optionally paused locally.

Without a dedicated runtime engine:

* speed controls accidentally auto-advance the stepper
* edge pulses and log entries drift out of sync
* “Next step” becomes meaningless because multiple events land per click
* animation timing becomes arbitrary and untrustworthy
* logs cannot be replayed (no determinism)

---

## THE PATTERN

**Stepper-Gated Event Release + Realtime Playback Scheduler**

The runtime_engine is a **gate** and a **clock**, but never both at the same time:

* In **stepper**: gate controls release, clock does not advance simulation
* In **realtime**: clock schedules rendering (and optional local pause), gate is disabled

Key insight:

> “Speed” is a **presentation rate**, not an authorization to advance state.
> The authorization to advance in stepper mode is only the Next button.

---

## PRINCIPLES

### Principle 1: Authorization vs pacing are separate

* Authorization to advance:

  * stepper: Next button only
  * realtime: event arrival + local pause toggle
* Pacing:

  * affects animation duration and progress indicators
  * must not change how many steps are released per user action in stepper mode

### Principle 2: Minimum truthful time

Every visible traversal animation must:

* reflect measured/declared duration when known
* never be shorter than 200ms (trust and readability)
* never imply “instant” when the system is slow (progress widgets handle waiting)

### Principle 3: Deterministic replay

Stepper playback must be replayable:

* same step script → same event sequence
* timestamps may differ, ordering must not

---

## DATA

| Data            | Description                                          |
| --------------- | ---------------------------------------------------- |
| `FlowEvent`     | canonical normalized event object (from event_model) |
| `StepScript`    | ordered list of raw steps (simulator)                |
| `RuntimeMode`   | `stepper` | `realtime`                               |
| `SpeedSetting`  | `pause` | `1x` | `2x` | `3x` (presentation)          |
| `PlaybackState` | cursor, paused flag, buffers, active highlights      |

---

## DEPENDENCIES

| Module              | Dependency Type        | Why                                                                         |
| ------------------- | ---------------------- | --------------------------------------------------------------------------- |
| `event_model`       | required               | runtime_engine releases FlowEvents only                                     |
| `state_store`       | required               | runtime_engine writes “current step”, “active highlight”, “progress timing” |
| `telemetry_adapter` | optional (v1 deferred) | realtime event source                                                       |
| `log_panel`         | required               | UI must reflect exactly what runtime released                               |

---

## INSPIRATIONS

* debuggers (single-step vs run)
* trace viewers (spans with durations)
* event-sourcing (immutable ledger, deterministic replay)

---

## SCOPE

### In Scope

* stepper gating logic (Next releases exactly one step)
* realtime playback scheduling (optional local pause/resume)
* animation timing policy (min 200ms, use duration if known)
* progress timing surfaces (player wait bar, tick wait node) as *signals* (not rendering)

### Out of Scope

* storing events ledger (state_store owns)
* rendering edges/nodes (edge_kit/node_kit own)
* SSE ingestion specifics (telemetry_adapter owns)
* backend truth invariants (Tempo/Canon correctness not owned here)

---

## DATA STRUCTURES

### RuntimeCommand

$$$
RuntimeCommand:
kind: next_step | restart | set_mode | set_speed | set_local_pause
payload: {...} | null
$$$

### RuntimeReleaseResult

$$$
RuntimeReleaseResult:
released_event: FlowEvent | null
status: released | blocked | end_of_script
notes: string | null
$$$

---

## ENTRY POINTS

| Entry Point                            | Purpose                                                    |
| -------------------------------------- | ---------------------------------------------------------- |
| `dispatch_runtime_command(cmd)`        | single entry for UI actions                                |
| `release_next_step()`                  | stepper: release exactly one event                         |
| `attach_realtime_stream(source)`       | realtime: bind event source to release pipeline (deferred) |
| `compute_animation_duration_ms(event)` | unify duration policy                                      |

---

## DATA FLOW AND DOCKING (FLOW-BY-FLOW)

### stepper_next_step_release: user click → one FlowEvent released

$$$
flow:
name: stepper_next_step_release
purpose: One click releases exactly one event, updates highlight, appends to ledger.
steps:
- read current cursor from state_store
- take next raw step from script
- normalize raw step → FlowEvent (event_model)
- compute animation duration (>=200ms)
- write highlight + explanation + append event to ledger (state_store)
docking_points:
- dock_release_next_step_result (event): emitted after release, used by HEALTH
$$$

### realtime_event_arrival_release: stream event → release if not locally paused (deferred)

$$$
flow:
name: realtime_event_arrival_release
purpose: Convert incoming telemetry into FlowEvents and render continuously.
steps:
- receive telemetry payload
- normalize → FlowEvent
- if local_pause=true: buffer
- else: append + animate + update highlights
docking_points:
- dock_realtime_buffer_size (metric): used by HEALTH
$$$

---

## LOGIC CHAINS

### LC1: Next click (stepper)

$$$
UI Next click
→ runtime_engine.dispatch_runtime_command(next_step)
→ runtime_engine.release_next_step()
→ event_model.normalize_flow_event(raw_step)
→ state_store.append_event(event)
→ log_panel renders from ledger
$$$

### LC2: Realtime arrival (deferred)

$$$
telemetry_adapter.on_event(payload)
→ runtime_engine.try_release_realtime_event(payload)
→ event_model.normalize_flow_event(payload)
→ state_store.append_event(event)
→ flow_canvas animates
$$$

---

## MODULE DEPENDENCIES

### Internal Dependencies

$$$
runtime_engine
→ imports event_model (normalize)
→ calls state_store (append + set focus)
→ emits signals consumed by flow_canvas/log_panel (via store)
$$$

### External Dependencies

None required for v1 (keep it framework-agnostic).
(React timers and requestAnimationFrame live in rendering modules, not here.)

---

## STATE MANAGEMENT

### Where State Lives

State lives in `state_store`. runtime_engine must be stateless except for:

* a private pointer to the active step script (or script id)
* a reference to the realtime subscription handle (deferred)

### State Transitions

$$$
stepper:
idle → (Next) → released → idle
end_of_script → (Next) → end_of_script
any → (Restart) → idle + cursor=0

realtime:
running → (LocalPause) → paused(buffering)
paused → (Resume) → draining → running
$$$

---

## RUNTIME BEHAVIOR

### Initialization

* load step script (simulator)
* set mode=stepper, speed=pause by default (presentation only)
* cursor=0, ledger empty

### Main Loop / Request Cycle

* stepper: reacts only to commands (Next/Restart/Mode)
* realtime: reacts to incoming events + local pause toggle (deferred)

### Shutdown

* unsubscribe realtime stream if attached (deferred)
* no other cleanup required

---

## CONCURRENCY MODEL

* stepper: single-threaded, command-serial
* realtime (deferred): events may arrive concurrently; runtime_engine must serialize release into store (queue)

---

## CONFIGURATION

| Config                | Default | Notes                                  |
| --------------------- | ------- | -------------------------------------- |
| `MIN_ANIMATION_MS`    | 200     | clamp for trust                        |
| `MAX_WAIT_PROGRESS_S` | 4.0     | used by progress widgets (signal only) |
| `DEFAULT_MODE`        | stepper | v1 default                             |
| `DEFAULT_SPEED`       | pause   | v1 default                             |

---

## BIDIRECTIONAL LINKS

### Code → Docs

To add during implementation:

* runtime_engine source file should contain:

  * `# DOCS: docs/connectome/runtime_engine/...`

### Docs → Code

* Algorithm maps to `release_next_step()` implementation
* Validation maps to runtime_engine health runner checks

---

## GAPS / IDEAS / QUESTIONS

### Extraction Candidates

* If realtime buffering grows complex, split buffering policy into a helper file (still inside runtime_engine module).

### Missing Implementation

* [ ] Implement `dispatch_runtime_command` + `release_next_step`
* [ ] Define step script interface used by simulator (or import from runtime_engine)

### Ideas

* IDEA: support “step back” (reverse) by storing cursor snapshots (v2+)

### Questions

* QUESTION: Should speed selection be stored as part of runtime_engine or purely UI state? (recommended: runtime_engine owns it as a semantic config)
* QUESTION: Do we need separate “visual speed” vs “nominal tick rate” fields? (likely yes)

---

---

### docs/connectome/runtime_engine/BEHAVIORS_Connectome_Runtime_Engine_User_Controlled_Traversal_Effects.md

$$$

# runtime_engine — Behaviors: User-Controlled Traversal and Playback Effects

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Runtime_Engine_Stepper_And_Realtime_Traversal_Control_Patterns.md
THIS:            BEHAVIORS_Connectome_Runtime_Engine_User_Controlled_Traversal_Effects.md (you are here)
ALGORITHM:       ./ALGORITHM_Connectome_Runtime_Engine_Step_Release_And_Realtime_Scheduling.md
VALIDATION:      ./VALIDATION_Connectome_Runtime_Engine_Invariants_For_Stepper_And_Realtime.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Runtime_Engine_Code_Structure_And_Control_Surface.md
HEALTH:          ./HEALTH_Connectome_Runtime_Engine_Runtime_Verification_Of_Pacing_And_Order.md
SYNC:            ./SYNC_Connectome_Runtime_Engine_Sync_Current_State.md
$$$

---

## BEHAVIORS

### B1: Next releases exactly one step, regardless of speed

$$$
GIVEN:  mode=stepper and user clicks Next
WHEN:   runtime_engine processes the command
THEN:   exactly one FlowEvent is released into the ledger
AND:    exactly one edge + one node-step highlight becomes “active”
AND:    glow persists until the next click
$$$

### B2: Speed changes animation time, not authorization

$$$
GIVEN:  mode=stepper and user changes speed (pause/1x/2x/3x)
THEN:   the nominal rate display changes and pulse animation duration changes
BUT:    Next still releases one and only one step
$$$

### B3: Realtime mode autoplays, stepper never autoplays

$$$
GIVEN:  mode=realtime
WHEN:   events arrive (SSE or derived)
THEN:   events release automatically unless locally paused

GIVEN:  mode=stepper
THEN:   no event releases without an explicit Next click
$$$

---

## INPUTS / OUTPUTS

### Primary Function: `dispatch_runtime_command()`

**Inputs**

| Name  | Type           | Notes                                                |
| ----- | -------------- | ---------------------------------------------------- |
| `cmd` | RuntimeCommand | next_step/restart/set_mode/set_speed/set_local_pause |

**Outputs**

| Name     | Type                 | Notes                          |
| -------- | -------------------- | ------------------------------ |
| `result` | RuntimeReleaseResult | released/blocked/end_of_script |

---

## EDGE CASES

### E1: End of script

$$$
GIVEN:  cursor is at last step
WHEN:   user clicks Next
THEN:   result=end_of_script and no new event is appended
AND:    UI explanation states “end reached”
$$$

### E2: Realtime burst while locally paused (deferred)

$$$
GIVEN:  local_pause=true in realtime
WHEN:   many events arrive quickly
THEN:   events are buffered with bounded retention (policy in state_store ?)
AND:    buffer size is visible as a health signal
$$$

---

## ANTI-BEHAVIORS

### A1: Speed accidentally triggers autoplay in stepper

$$$
MUST NOT: releasing multiple events because speed=3x
INSTEAD: speed only modifies animation duration + nominal rate text
$$$

### A2: UI bypasses runtime_engine and appends to ledger directly

$$$
MUST NOT: components append events without runtime_engine release
INSTEAD: all user-facing releases go through runtime_engine gate
$$$

---

## STATE MANAGEMENT

### Where State Lives

* cursor, mode, speed, pause flags live in `state_store`
* runtime_engine mutates store through explicit actions only

### State Transitions

(see PATTERNS → State Transitions)

---

## RUNTIME BEHAVIOR

### Initialization

* mode=stepper, speed=pause, cursor=0

### Main Loop / Request Cycle

* command-driven in stepper
* event-driven in realtime (deferred)

### Shutdown

* cleanly detach realtime listener (deferred)

---

## CONCURRENCY MODEL

* stepper commands are serialized
* realtime events are queued and drained (deferred)

---

## CONFIGURATION

* MIN_ANIMATION_MS = 200
* MAX_WAIT_PROGRESS_S = 4.0

---

## BIDIRECTIONAL LINKS

### Code → Docs

* runtime_engine implementation must reference this chain in file header comments

### Docs → Code

* behaviors map to runtime_engine unit-level health checks (see HEALTH)

---

## GAPS / IDEAS / QUESTIONS

### Extraction Candidates

* if buffering policies expand: extract to a dedicated buffering policy helper

### Missing Implementation

* [ ] stepper script interface + release logic
* [ ] realtime mode adapter integration (deferred)

### Ideas

* IDEA: “step back” debugging
* IDEA: “jump to step N” with deterministic cursor movement

### Questions

* QUESTION: should realtime mode support “single-step realtime” (consume one buffered event per Next)? (maybe v2)

---

---

### docs/connectome/runtime_engine/ALGORITHM_Connectome_Runtime_Engine_Step_Release_And_Realtime_Scheduling.md

$$$

# runtime_engine — Algorithm: Step Release Gate and Realtime Scheduling

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Runtime_Engine_Stepper_And_Realtime_Traversal_Control_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Runtime_Engine_User_Controlled_Traversal_Effects.md
THIS:            ALGORITHM_Connectome_Runtime_Engine_Step_Release_And_Realtime_Scheduling.md (you are here)
VALIDATION:      ./VALIDATION_Connectome_Runtime_Engine_Invariants_For_Stepper_And_Realtime.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Runtime_Engine_Code_Structure_And_Control_Surface.md
HEALTH:          ./HEALTH_Connectome_Runtime_Engine_Runtime_Verification_Of_Pacing_And_Order.md
SYNC:            ./SYNC_Connectome_Runtime_Engine_Sync_Current_State.md
$$$

---

## OVERVIEW

runtime_engine is a small controller that:

* receives UI commands (Next/Restart/Mode/Speed)
* releases exactly one FlowEvent per Next in stepper mode
* schedules continuous release in realtime mode (deferred)
* applies minimum animation duration policy (>=200ms)

It does not render and does not store ledgers directly.

---

## DATA STRUCTURES

### `RuntimeCommand`

(see PATTERNS)

### `RuntimeReleaseResult`

(see PATTERNS)

---

## ALGORITHM: `release_next_step()`

### Step 1: Guard conditions

* If mode != stepper → return blocked (wrong mode)
* If cursor at end → return end_of_script

### Step 2: Fetch raw step

* raw_step = step_script[cursor]
* cursor_next = cursor + 1 (store update happens after successful normalization)

### Step 3: Normalize to FlowEvent

* event = event_model.normalize_flow_event(raw_step)
* If event invalid → preserve unknowns “?” and proceed (never drop)

### Step 4: Compute animation duration

* duration_ms = clamp(event.duration_ms ?? default_for_speed, MIN_ANIMATION_MS)

### Step 5: Commit to store (single atomic update)

* append event to ledger
* set “active focus” (active node id, active edge id, active step_key)
* set explanation text for this step
* set cursor=cursor_next

### Step 6: Return result

* return released with event id

---

## ALGORITHM: `dispatch_runtime_command(cmd)`

### Step 1: Switch on cmd.kind

* next_step → call release_next_step()
* restart → reset cursor, clear active focus, clear ledger (or clear view) (policy in state_store)
* set_mode → stepper/realtime
* set_speed → store speed; affects duration defaults + progress widgets
* set_local_pause → only used in realtime

### Step 2: Emit result for UI

* return RuntimeReleaseResult (released/blocked/end_of_script)

---

## KEY DECISIONS

### D1: Duration default policy

$$$
default_duration_for_speed(speed):
pause: 650ms
1x:    650ms
2x:    450ms
3x:    300ms
and then clamp to MIN_ANIMATION_MS=200ms
$$$

Rationale:

* speed changes “feel” without changing authorization

### D2: End-of-script behavior

$$$
When end reached:
do not wrap automatically
require Restart
$$$

Rationale:

* preserves debugging clarity and prevents surprise loops

---

## DATA FLOW

$$$
UI command
→ runtime_engine.dispatch_runtime_command
→ (optional) release_next_step
→ event_model.normalize_flow_event
→ state_store.commit_update (append + focus + explanation + cursor)
$$$

---

## COMPLEXITY

* stepper release: O(1) per click
* realtime (deferred): O(1) per event + optional buffering

---

## HELPER FUNCTIONS

### `compute_animation_duration_ms(event, speed)`

* returns >=200ms
* returns declared duration if available and >200ms

### `build_explanation_sentence(event)`

* produces one truthful sentence for the unified log/explain panel
* if unknown: adds “?” marker

---

## INTERACTIONS

| Module                       | Interaction                               |
| ---------------------------- | ----------------------------------------- |
| event_model                  | normalize raw step/payload → FlowEvent    |
| state_store                  | commit atomic state updates for release   |
| telemetry_adapter (deferred) | provide realtime payload stream           |
| log_panel                    | reads store and displays current + ledger |

---

## GAPS / IDEAS / QUESTIONS

* [ ] Decide ledger reset policy on Restart (clear all vs mark new cycle boundary)
* QUESTION: Should “Restart” preserve old logs and start a new session id? (likely yes for copy/export)

---

---

### docs/connectome/runtime_engine/VALIDATION_Connectome_Runtime_Engine_Invariants_For_Stepper_And_Realtime.md

$$$

# runtime_engine — Validation: Invariants for Stepper Gating and Realtime Playback

STATUS: DRAFT
CREATED: 2025-12-20
VERIFIED: 2025-12-20 against ?
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Runtime_Engine_Stepper_And_Realtime_Traversal_Control_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Runtime_Engine_User_Controlled_Traversal_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Runtime_Engine_Step_Release_And_Realtime_Scheduling.md
THIS:            VALIDATION_Connectome_Runtime_Engine_Invariants_For_Stepper_And_Realtime.md (you are here)
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Runtime_Engine_Code_Structure_And_Control_Surface.md
HEALTH:          ./HEALTH_Connectome_Runtime_Engine_Runtime_Verification_Of_Pacing_And_Order.md
SYNC:            ./SYNC_Connectome_Runtime_Engine_Sync_Current_State.md
$$$

---

## INVARIANTS

### V1: One Next click releases exactly one event (stepper mode)

$$$
IF mode==stepper AND command==next_step AND not end_of_script:
ledger_length increases by exactly 1
cursor increases by exactly 1
$$$

### V2: Speed does not change authorization (stepper mode)

$$$
IF mode==stepper:
changing speed must not change ledger_length or cursor
only affects computed animation duration defaults
$$$

### V3: Minimum duration clamp

$$$
FOR every released event:
animation_duration_ms >= 200ms
$$$

---

## PROPERTIES

### P1: Deterministic replay (stepper)

$$$
Given same step_script and same starting state:
sequence of released FlowEvents is identical (ignoring timestamps)
$$$

### P2: End-of-script is stable

$$$
After reaching end_of_script:
further next_step commands do not append events
$$$

---

## ERROR CONDITIONS

### E1: Double release per click

$$$
SYMPTOM: ledger_length increases by >1 for a single Next command
SEVERITY: ERROR
$$$

### E2: Autoplay leak in stepper mode

$$$
SYMPTOM: events released without a Next command when mode==stepper
SEVERITY: ERROR
$$$

---

## HEALTH COVERAGE

| Validation | Health Indicator                                 |
| ---------- | ------------------------------------------------ |
| V1         | runtime_stepper_single_step_integrity            |
| V2         | runtime_speed_authorization_separation           |
| V3         | runtime_min_duration_enforced                    |
| P1         | runtime_stepper_replay_determinism (optional v1) |
| E1/E2      | runtime_autoplay_leak_detector                   |

---

## VERIFICATION PROCEDURE

### Manual Checklist

$$$
[ ] Click Next once → exactly one new log entry
[ ] Switch speed to 3x → click Next once → still exactly one entry
[ ] Run to end → click Next → no new entry; UI says end reached
[ ] Set a step duration to 10ms → animation still takes >=200ms
$$$

### Automated

$$$
pnpm connectome:health runtime_engine
$$$

---

# Run tests

$$$
pnpm connectome:health runtime_engine
$$$

# Run with coverage

$$$
pnpm connectome:health runtime_engine --coverage
$$$

---

## SYNC STATUS

$$$
LAST_VERIFIED: 2025-12-20
VERIFIED_AGAINST:
impl: ?
health: ?
RESULT:
V1: NOT RUN
V2: NOT RUN
V3: NOT RUN
$$$

---

## GAPS / IDEAS / QUESTIONS

* QUESTION: Do we treat “Restart” as a new session boundary in determinism checks?
* IDEA: Add a “command ledger” (Next/Restart/Mode changes) for auditability (v2)

---

---

### docs/connectome/runtime_engine/HEALTH_Connectome_Runtime_Engine_Runtime_Verification_Of_Pacing_And_Order.md

$$$

# runtime_engine — Health: Verification Mechanics and Coverage

STATUS: DRAFT
CREATED: 2025-12-20
$$$

---

## PURPOSE OF THIS FILE

This HEALTH file verifies that runtime_engine preserves the guarantees that make /connectome a trustworthy debugger:

* stepper: one click → one event
* speed: presentation only (no authorization leak)
* minimum animation duration enforced
* no autoplay leaks in stepper mode

This file does not verify:

* edge rendering correctness (edge_kit)
* ledger storage correctness (state_store)
* backend correctness (Tempo/Canon invariants)

---

## WHY THIS PATTERN

Stepper dashboards fail silently: everything “looks animated” but the semantics are wrong.

HEALTH exists to make incorrect semantics visible:

* a double-release becomes a red indicator immediately
* an autoplay leak becomes a red indicator immediately

---

## HOW TO USE THIS TEMPLATE

* Define the flows runtime_engine owns (stepper release; mode switch)
* Define checkers that can sample store state transitions
* Emit a simple enum status: OK/WARN/ERROR

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Runtime_Engine_Stepper_And_Realtime_Traversal_Control_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Runtime_Engine_User_Controlled_Traversal_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Runtime_Engine_Step_Release_And_Realtime_Scheduling.md
VALIDATION:      ./VALIDATION_Connectome_Runtime_Engine_Invariants_For_Stepper_And_Realtime.md
IMPLEMENTATION:  ./IMPLEMENTATION_Connectome_Runtime_Engine_Code_Structure_And_Control_Surface.md
THIS:            HEALTH_Connectome_Runtime_Engine_Runtime_Verification_Of_Pacing_And_Order.md
SYNC:            ./SYNC_Connectome_Runtime_Engine_Sync_Current_State.md

IMPL:            ? (planned) scripts/connectome/health/runtime_engine_health_check_runner.ts
$$$

---

## FLOWS ANALYSIS (TRIGGERS + FREQUENCY)

$$$
flows_analysis:

* flow_id: runtime_engine_stepper_next_step_release
  purpose: Guarantee “one Next → one event” and no autoplay.
  triggers:

  * type: manual
    source: UI button "Next step"
    notes: direct user command
    frequency:
    expected_rate: "human-driven: <= 5/min typical; burst <= 5/s"
    peak_rate: "human-driven; bounded"
    burst_behavior: "must remain correct under rapid clicking"
    risks:
  * "double-release bug"
  * "cursor desync"
  * "duration clamp missing"
    notes: "Realtime not required for v1"

* flow_id: runtime_engine_speed_change
  purpose: Ensure speed does not release steps in stepper mode.
  triggers:

  * type: manual
    source: UI speed selector
    frequency:
    expected_rate: "rare"
    peak_rate: "user spam"
    burst_behavior: "must not alter ledger/cursor"
    risks:
  * "autoplay leak due to speed timer"
    notes: "Speed is presentation only in stepper"
    $$$

---

## HEALTH INDICATORS SELECTED

$$$
health_indicators:

* name: runtime_stepper_single_step_integrity
  flow_id: runtime_engine_stepper_next_step_release
  priority: high
  rationale: "If broken, /connectome cannot be trusted."

* name: runtime_speed_authorization_separation
  flow_id: runtime_engine_speed_change
  priority: high
  rationale: "Prevents the most common regression: speed triggers autoplay."

* name: runtime_min_duration_enforced
  flow_id: runtime_engine_stepper_next_step_release
  priority: med
  rationale: "Trust + readability requirement."

* name: runtime_autoplay_leak_detector
  flow_id: runtime_engine_stepper_next_step_release
  priority: high
  rationale: "Any release without Next in stepper is catastrophic."
  $$$

---

## STATUS (RESULT INDICATOR)

$$$
status:
stream_destination: "file:?/var/connectome/health/runtime_engine_status.json"
result:
representation: enum
value: UNKNOWN
updated_at: "2025-12-20T00:00:00+01:00"
source: runtime_stepper_single_step_integrity
$$$

---

## DOCK TYPES (COMPLETE LIST)

* event (Next click, speed change)
* file (exported status JSON)
* config (MIN_ANIMATION_MS)
* metric (ledger length deltas, cursor deltas)

---

## CHECKER INDEX

$$$
checkers:

* name: health_check_stepper_one_click_one_event
  purpose: "Assert V1: ledger+cursor increments exactly 1 per Next."
  status: pending
  priority: high

* name: health_check_speed_does_not_release_steps
  purpose: "Assert V2: speed changes do not change ledger/cursor."
  status: pending
  priority: high

* name: health_check_min_duration_clamp_applied
  purpose: "Assert V3: duration >= 200ms for all releases."
  status: pending
  priority: med

* name: health_check_autoplay_leak_in_stepper_mode
  purpose: "Assert E2: no events appended without Next command."
  status: pending
  priority: high
  $$$

---

## INDICATOR: runtime_stepper_single_step_integrity

### VALUE TO CLIENTS & VALIDATION MAPPING

$$$
value_and_validation:
indicator: runtime_stepper_single_step_integrity
client_value: "Agents can single-step the pipeline and trust semantics."
validation:
- validation_id: V1
criteria: "One Next releases exactly one event and advances cursor by 1."
$$$

### HEALTH REPRESENTATION

$$$
representation:
selected: [enum]
semantics:
enum: "OK=always 1; WARN=rare mismatch but detected; ERROR=double-release or cursor desync"
aggregation:
method: "worst_state"
$$$

### DOCKS SELECTED

$$$
docks:
input:
- id: dock_next_command_received
type: event
location: connectome/runtime_engine:dispatch_runtime_command (?)
output:
- id: dock_ledger_length_after_release
type: metric
location: connectome/state_store:append_event (?)
- id: dock_cursor_after_release
type: metric
location: connectome/state_store:set_cursor (?)
$$$

### ALGORITHM / CHECK MECHANISM

$$$
mechanism:
steps:
- "On each Next command, record ledger_length_before and cursor_before"
- "After release completes, record ledger_length_after and cursor_after"
- "Assert deltas are exactly 1 unless end_of_script"
- "Emit OK/WARN/ERROR"
$$$

### INDICATOR

$$$
indicator:
error:
- name: double_release_detected
linked_validation: [V1]
meaning: "More than one event released for one Next"
default_action: page
warning:
- name: cursor_mismatch_detected
linked_validation: [V1]
meaning: "Cursor did not match ledger increment"
default_action: warn/log
info:
- name: single_step_ok
linked_validation: [V1]
meaning: "Deltas correct"
default_action: log
$$$

### THROTTLING STRATEGY

$$$
throttling:
trigger: event
max_frequency: "1/0s"   # evaluate every Next click
burst_limit: 100
backoff: "none"
$$$

### FORWARDINGS & DISPLAYS

$$$
forwarding:
targets:
- location: "/connectome UI header badge — runtime_engine"
transport: event
display:
locations:
- surface: UI
location: "Log panel header"
signal: "OK/WARN/ERROR badge with tooltip counts"
$$$

### MANUAL RUN

$$$
manual_run:
command: "pnpm connectome:health runtime_engine"
$$$

---

## HOW TO RUN

$$$
pnpm connectome:health runtime_engine
pnpm connectome:health runtime_engine --checker health_check_stepper_one_click_one_event
$$$

---

## KNOWN GAPS

* [ ] Dock locations are unknown until implementation exists (file:line = ?)
* [ ] Realtime-related indicators are deferred for v1

---

## GAPS / IDEAS / QUESTIONS

* IDEA: Add a “rapid-click fuzz” mode to stress test V1 quickly.
* QUESTION: Should health checks run in CI, or only as an on-demand dev tool?

---

---

### docs/connectome/runtime_engine/SYNC_Connectome_Runtime_Engine_Sync_Current_State.md

$$$

# runtime_engine — Sync: Current State

LAST_UPDATED: 2025-12-20
UPDATED_BY: Marco "Salthand" (agent)
STATUS: DESIGNING
$$$

---

## MATURITY

**Canonical (v1 intent):**

* stepper: Next releases exactly one event, speed never autoplays
* min duration clamp 200ms

**In design:**

* restart policy (clear ledger vs session boundary)
* realtime mode buffering (deferred)

**Deferred:**

* realtime adapter wiring
* buffering policy and retention

---

## CURRENT STATE

runtime_engine docs are defined; implementation does not exist yet. The engine is explicitly separated from state_store (storage) and from rendering (flow_canvas, node_kit, edge_kit).

---

## IN PROGRESS

### Stepper engine scaffolding

* Status: not implemented
* Next: implement command dispatch + step release using event_model normalization

---

## RECENT CHANGES

### 2025-12-20: Initialized runtime_engine chain docs

* Defined gating semantics and invariants
* Defined health checks that detect autoplay leaks

---

## KNOWN ISSUES

### Realtime ambiguity

* Issue: realtime ordering + buffering policy not decided
* Impact: telemetry_adapter + runtime_engine realtime mode cannot be finalized
* Current handling: deferred; marked `?`

---

## HANDOFF: FOR AGENTS

* Start at IMPLEMENTATION doc: create files with long descriptive names
* Ensure event_model is imported; do not duplicate normalization
* Ensure speed change does NOT schedule timers in stepper mode

---

## HANDOFF: FOR HUMAN

* V1 decision needed: Restart clears ledger or creates session boundary?
* V1 can ship without realtime

---

## TODO

### Doc/Impl Drift

* [ ] Implement runtime_engine per ALGORITHM
* [ ] Add health harness that can observe ledger/cursor deltas

### Tests to Run

$$$
pnpm connectome:health runtime_engine
$$$

### Immediate

* [ ] Build step script interface used by simulator
* [ ] Implement release_next_step with min duration clamp

### Later

* [ ] Realtime buffering and drain policy
* [ ] “Step back” support

---

## CONSCIOUSNESS TRACE

* Key risk: accidentally implementing autoplay via speed timers
* Key invariant: authorization is Next button only (stepper)

---

## POINTERS

| Item                   | Location                             |
| ---------------------- | ------------------------------------ |
| FlowEvent contract     | docs/connectome/event_model/* |
| Step gating invariants | VALIDATION file in this module       |

---

---

### docs/connectome/runtime_engine/IMPLEMENTATION_Connectome_Runtime_Engine_Code_Structure_And_Control_Surface.md

$$$

# runtime_engine — Implementation: Code Architecture and Structure

STATUS: DRAFT
CREATED: 2025-12-20
$$$

---

## CHAIN

$$$
PATTERNS:        ./PATTERNS_Connectome_Runtime_Engine_Stepper_And_Realtime_Traversal_Control_Patterns.md
BEHAVIORS:       ./BEHAVIORS_Connectome_Runtime_Engine_User_Controlled_Traversal_Effects.md
ALGORITHM:       ./ALGORITHM_Connectome_Runtime_Engine_Step_Release_And_Realtime_Scheduling.md
VALIDATION:      ./VALIDATION_Connectome_Runtime_Engine_Invariants_For_Stepper_And_Realtime.md
THIS:            IMPLEMENTATION_Connectome_Runtime_Engine_Code_Structure_And_Control_Surface.md
HEALTH:          ./HEALTH_Connectome_Runtime_Engine_Runtime_Verification_Of_Pacing_And_Order.md
SYNC:            ./SYNC_Connectome_Runtime_Engine_Sync_Current_State.md

IMPL:            app/connectome/lib/next_step_gate_and_realtime_playback_runtime_engine.ts (PROPOSED)
$$$

---

## CODE STRUCTURE

$$$
app/
└── connectome/
├── lib/
│   ├── next_step_gate_and_realtime_playback_runtime_engine.ts
│   ├── minimum_duration_clamp_and_speed_based_default_policy.ts
│   └── step_script_cursor_and_replay_determinism_helpers.ts
$$$

### File Responsibilities

| File                                                       | Responsibility                                                    | Key Exports                                     |
| ---------------------------------------------------------- | ----------------------------------------------------------------- | ----------------------------------------------- |
| `next_step_gate_and_realtime_playback_runtime_engine.ts`   | command dispatch + step release gate + realtime attach (deferred) | `dispatch_runtime_command`, `release_next_step` |
| `minimum_duration_clamp_and_speed_based_default_policy.ts` | duration policy + thresholds                                      | `compute_animation_duration_ms`                 |
| `step_script_cursor_and_replay_determinism_helpers.ts`     | cursor movement + stable ids for stepper                          | `make_stepper_event_id`, `advance_cursor`       |

---

## DESIGN PATTERNS

### Architecture Pattern

* Gate + scheduler split by mode (stepper vs realtime)

### Code Patterns in Use

* pure helpers for deterministic outputs
* table-driven speed → default duration mapping

### Anti-Patterns to Avoid

* timers that release events in stepper mode
* direct store mutation from UI components
* duplicating event_model normalization

### Boundaries

| Boundary                 | Inside              | Outside                                 |
| ------------------------ | ------------------- | --------------------------------------- |
| Runtime control boundary | gating + scheduling | rendering, storage, telemetry transport |

---

## SCHEMA

### RuntimeCommand

(see PATTERNS)

### RuntimeReleaseResult

(see PATTERNS)

---

## ENTRY POINTS

| Entry Point                           | Trigger                                                |
| ------------------------------------- | ------------------------------------------------------ |
| `dispatch_runtime_command(cmd)`       | UI actions                                             |
| `release_next_step()`                 | called only from `dispatch_runtime_command(next_step)` |
| `attach_realtime_stream()` (deferred) | telemetry adapter                                      |

---

## DATA FLOW AND DOCKING (FLOW-BY-FLOW)

### stepper_next_step_release: Next click → one event

$$$
flow:
name: stepper_next_step_release
steps:
- id: cmd_received
file: app/connectome/lib/next_step_gate_and_realtime_playback_runtime_engine.ts
function: dispatch_runtime_command
trigger: direct
output: RuntimeReleaseResult (released/blocked/end_of_script)
- id: normalize
file: app/connectome/lib/next_step_gate_and_realtime_playback_runtime_engine.ts
function: release_next_step
trigger: direct
output: FlowEvent
notes: "calls event_model.normalize_flow_event"
- id: store_commit
file: app/connectome/state_store (?)
function: commit_release (?)
trigger: direct
output: state updated
docking_points:
- id: dock_runtime_release_result
type: event
direction: output
file: app/connectome/lib/next_step_gate_and_realtime_playback_runtime_engine.ts
function: release_next_step
payload: RuntimeReleaseResult
notes: "HEALTH observes one-click-one-event"
$$$

---

## STATE MANAGEMENT

### Where State Lives

* cursor, mode, speed, pause in `state_store`

### State Transitions

(see runtime_engine PATTERNS)

---

## RUNTIME BEHAVIOR

### Initialization

* bind step script
* set defaults (mode=stepper, speed=pause)

### Main Loop / Request Cycle

* command-driven, synchronous per click

### Shutdown

* detach realtime subscription (deferred)

---

## CONCURRENCY MODEL

* serialize commands
* realtime queue drain policy deferred

---

## CONFIGURATION

| Config           | Default |
| ---------------- | ------- |
| MIN_ANIMATION_MS | 200     |
| DEFAULT_SPEED    | pause   |
| DEFAULT_MODE     | stepper |

---

## BIDIRECTIONAL LINKS

### Code → Docs

* add doc pointer headers to the TS files

### Docs → Code

* V1 invariants enforced by release_next_step

---

## GAPS / IDEAS / QUESTIONS

### Extraction Candidates

* if realtime introduces buffering complexity → extract buffer policy to a separate helper

### Missing Implementation

* [ ] implement runtime engine TS files
* [ ] add health runner (scripts/connectome/health/runtime_engine_health_check_runner.ts)

### Ideas

* IDEA: session boundaries for restart, preserve previous logs

### Questions

* QUESTION: Should restart clear ledger or mark boundary? (pending human decision)
