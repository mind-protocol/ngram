"""
Blood Ledger â€” World Runner Service

Calls agent CLI to resolve flips (tension breaks).
Stateless - no --continue, each call is independent.
"""

# DOCS: docs/agents/world-runner/PATTERNS_World_Runner.md

import json
import subprocess
import logging
from typing import Dict, Any, List
from pathlib import Path

from .agent_cli import parse_claude_json_output, run_agent

from engine.physics.graph.graph_ops import GraphOps

from engine.physics.graph.graph_queries import GraphQueries



logger = logging.getLogger(__name__)





class WorldRunnerService:

    """

    Service for calling the World Runner agent via agent CLI.

    """



    def __init__(

        self,

        graph_ops: GraphOps,

        graph_queries: GraphQueries, # Added GraphQueries instance

        working_dir: str = None,

        timeout: int = 600  # 10 minutes

    ):

        self.graph_ops = graph_ops

        self.graph_queries = graph_queries # Store GraphQueries instance

        self.working_dir = working_dir or str(Path.cwd())

        self.timeout = timeout



        logger.info("[WorldRunnerService] Initialized")



    def process_flips(

        self,

        flips: List[Dict[str, Any]],

        graph_context: Dict[str, Any],

        player_context: Dict[str, Any],

        time_span: str = "unknown"

    ) -> Dict[str, Any]:

        """

        Process flipped tensions and determine what happened.



        Args:

            flips: List of flipped tensions

            graph_context: Relevant narratives and character info (now used in _build_prompt)

            player_context: Player location and state (now used in _build_prompt)

            time_span: Time span being processed



        Returns:

            WorldRunnerOutput dict with graph_mutations and world_injection

        """

        # Build prompt (now includes dynamic graph context)

        prompt = self._build_prompt(flips, graph_context, player_context, time_span)



        # Call agent CLI (stateless, no --continue)

        result = self._call_claude(prompt)



        # Apply graph mutations generated by the agent

        if "graph_mutations" in result and result["graph_mutations"]:

            try:

                self.graph_ops.apply(data=result["graph_mutations"])

                logger.info(f"[WorldRunnerService] Applied {len(result['graph_mutations'].get('new_narratives', []))} new narratives and other mutations.")

            except Exception as e:

                logger.error(f"[WorldRunnerService] Failed to apply graph mutations: {e}")

                # Fallback to a minimal response if mutations fail

                return self._fallback_response("Failed to apply mutations")



        return result



    def _build_prompt(

        self,

        flips: List[Dict[str, Any]],

        initial_graph_context: Dict[str, Any], # Renamed to avoid confusion with queried context

        initial_player_context: Dict[str, Any], # Renamed

        time_span: str

    ) -> str:

        """

        Build the world runner prompt with comprehensive graph context.

        Queries for detailed information about the flipped tensions and related entities.

        """

        import yaml



        # Extract flip_ids for graph queries

        flip_ids = [f['tension_id'] for f in flips]



        # 1. Get comprehensive details for each flipped tension and its related narratives

        tension_details = self.graph_queries.query("""

            MATCH (t:Tension) WHERE t.id IN $flip_ids

            OPTIONAL MATCH (t)-[:INVOLVES]->(n:Narrative)

            OPTIONAL MATCH (c:Character)-[:BELIEVES]->(n)

            OPTIONAL MATCH (n)-[:ABOUT]->(about_c:Character)

            OPTIONAL MATCH (n)-[:ABOUT]->(about_p:Place)

            OPTIONAL MATCH (n)-[:ABOUT]->(about_t:Thing)

            RETURN t.id, t.description, t.narrator_notes, t.pressure, t.breaking_point, t.pressure_type,

                   collect(DISTINCT {id: n.id, name: n.name, content: n.content, type: n.type, weight: n.weight, tone: n.tone}) AS involved_narratives,

                   collect(DISTINCT {id: about_c.id, name: about_c.name, type: about_c.type}) AS about_characters,

                   collect(DISTINCT {id: about_p.id, name: about_p.name, type: about_p.type}) AS about_places,

                   collect(DISTINCT {id: about_t.id, name: about_t.name, type: about_t.type}) AS about_things

            """,

            params={"flip_ids": flip_ids}

        )



        # 2. Get current locations and statuses of all relevant characters (from initial context for now)

        # For a full implementation, this might involve more complex graph queries

        # For now, we'll use the initial player_context if it has location data

        all_characters_at_locations = self.graph_queries.query("""

            MATCH (c:Character)-[r:AT]->(p:Place)

            RETURN c.id, c.name, p.id AS place_id, p.name AS place_name, r.present, r.visible

            """,

            params={}

        )



        # 3. Get character relationships (e.g., from BELIEVES links that might be strained)

        character_relationships = self.graph_queries.query("""

            MATCH (c1:Character)-[b:BELIEVES]->(n:Narrative)-[rel:RELATES_TO]->(n2:Narrative)<-[b2:BELIEVES]-(c2:Character)

            WHERE rel.contradicts > 0.5

            RETURN c1.id, c2.id, n.id, n2.id, rel.contradicts, b.believes, b2.believes

            """,

            params={}

        )



        # Combine all context for the AI agent

        full_graph_context = {

            "initial_context": initial_graph_context,

            "tension_details": tension_details,

            "character_locations": all_characters_at_locations,

            "character_relationships": character_relationships,

        }



        parts = [

            "WORLD RUNNER INSTRUCTION",

            "=" * 24,

            "",

            f"TIME_SPAN: {time_span}",

            "",

            "FLIPS:",

            yaml.dump(flips, default_flow_style=False),

            "",

            "GRAPH_CONTEXT:",

            yaml.dump(full_graph_context, default_flow_style=False),

            "",

            "PLAYER_CONTEXT:",

            yaml.dump(initial_player_context, default_flow_style=False),

            "",

            "Determine what happened during this time span.",

            "For each flip, determine:",

            "1. What specifically occurred",

            "2. Who witnessed it",

            "3. What new narratives emerge",

            "4. How beliefs change",

            "5. Any cascading effects",

            "",

            "Output JSON matching WorldRunnerOutput schema.",

        ]



        return "\n".join(parts)

    def _call_claude(self, prompt: str) -> Dict[str, Any]:
        """Call agent CLI and parse response."""
        # Stateless - no --continue
        try:
            result = run_agent(
                prompt,
                working_dir=self.working_dir,
                timeout=self.timeout,
                output_format="json",
            )

            if result.returncode != 0:
                logger.error(f"[WorldRunnerService] Agent CLI failed: {result.stderr}")
                return self._fallback_response(f"Agent CLI failed: {result.stderr}")

            return parse_claude_json_output(result.stdout)

        except subprocess.TimeoutExpired:
            logger.error("[WorldRunnerService] Agent CLI timed out")
            return self._fallback_response("Agent CLI timed out")
        except json.JSONDecodeError as e:
            logger.error(f"[WorldRunnerService] Failed to parse response: {e}")
            return self._fallback_response(f"Failed to parse response: {e}")
        except FileNotFoundError:
            logger.error("[WorldRunnerService] Agent CLI not found")
            return self._fallback_response("Agent CLI not found")

    def _fallback_response(self, message: str = "World Runner unavailable") -> Dict[str, Any]:
        """Return a minimal fallback response."""
        return {
            "thinking": f"Fallback response - {message}",
            "graph_mutations": {
                "new_narratives": [],
                "new_beliefs": [],
                "tension_updates": [],
                "new_tensions": [],
                "character_movements": [],
                "modifier_changes": []
            },
            "world_injection": {
                "time_since_last": "unknown",
                "breaks": [],
                "news_arrived": [],
                "tension_changes": {},
                "interruption": None,
                "atmosphere_shift": None,
                "narrator_notes": "World Runner unavailable - minimal response"
            }
        }
