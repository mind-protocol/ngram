# Protocol: capture_decision
# Record a significant decision with alternatives and rationale

protocol: capture_decision
version: "1.1"
description: Create a decision narrative with alternatives considered and rationale for choice

triggers:
  - event: "Significant design decision made"
  - event: "Investigation reveals decision point"
  - event: "Need to document why we chose X over Y"

requires_skills:
  - SKILL_Debug_Investigate_And_Fix_Issues_With_Evidence_First.md

contextual_knowledge:
  domain: |
    Decisions in ngram:
    - Decision = recorded choice with alternatives and rationale
    - Different from escalation: decision is already made, not blocked
    - Links to what it affects via `relates[affects]`

    Decision structure:
    - Question: what was being decided
    - Alternatives: what was considered
    - Choice: what was selected
    - Rationale: why this choice
    - Affects: what nodes are impacted

    Use decisions when:
    - Recording architectural choices
    - Documenting why code is shaped a certain way
    - Creating traceable design history
  constraints: |
    - Must capture the question being answered
    - Must list alternatives (at least 2)
    - Must explain why this choice over alternatives
    - Should link to affected nodes
  quality_criteria: |
    Good decision: "Question: How to validate coverage? Alternatives: (A) Manual review, (B) YAML spec + validator, (C) Database with UI. Choice: B. Rationale: Machine-checkable, diffable, no extra infrastructure."
    Bad decision: "Decided to use YAML"

steps:
  identify_context:
    type: ask
    auto_fetch:
      - query: { find: space }
        store_as: available_spaces
    context: |
      Decisions record significant choices with rationale.
      This creates traceable design history.
    questions:
      - name: space_id
        ask: "Which space/module does this decision affect?"
        expects:
          type: id
          node_type: space
    moment:
      agent_provides: [description]
    next: capture_question

  capture_question:
    type: ask
    context: |
      Space: {space_id}

      Frame the decision as a question that was answered.
    questions:
      - name: decision_question
        ask: "What question was being decided?"
        good_answer: "How should we validate that every doctor detection has a complete path to graph mutation?"
        bad_answer: "What to do about coverage"
        expects:
          type: string
          min_length: 10
      - name: decision_context
        ask: "What context led to this decision point?"
        expects:
          type: string
          min_length: 20
    moment:
      agent_provides: [description]
    next: capture_alternatives

  capture_alternatives:
    type: ask
    questions:
      - name: alternative_count
        ask: "How many alternatives were considered? (2-5)"
        expects:
          type: number
          min: 2
          max: 5
    next: alternatives_loop

  alternatives_loop:
    type: loop
    count: "{alternative_count}"
    step:
      type: ask
      questions:
        - name: alt_label
          ask: "Alternative {loop_index} label?"
          expects:
            type: string
        - name: alt_description
          ask: "What is this alternative?"
          expects:
            type: string
            min_length: 10
        - name: alt_pros
          ask: "Pros of this alternative?"
          expects:
            type: string
        - name: alt_cons
          ask: "Cons of this alternative?"
          expects:
            type: string
    collect_as: alternatives
    next: capture_choice

  capture_choice:
    type: ask
    context: |
      Question: {decision_question}

      Alternatives:
      {alternatives | format_numbered}
    questions:
      - name: choice
        ask: "Which alternative was chosen?"
        expects:
          type: string
      - name: rationale
        ask: "Why this choice over the alternatives?"
        good_answer: "YAML spec + validator is machine-checkable, version-controlled, and requires no infrastructure. Manual review doesn't scale. Database + UI adds complexity."
        expects:
          type: string
          min_length: 20
      - name: decided_by
        ask: "Who made this decision?"
        expects:
          type: string
      - name: decision_date
        ask: "When was this decided? (or 'now')"
        expects:
          type: string
          default: "now"
    moment:
      agent_provides: [description, reasoning]
    next: identify_affects

  identify_affects:
    type: ask
    auto_fetch:
      - query:
          find: narrative
          in_space: "{space_id}"
        store_as: space_contents
    context: |
      This decision may affect other nodes in the graph.

      Contents of {space_id}:
      {space_contents | format_list}
    questions:
      - name: affected_nodes
        ask: "Which nodes does this decision affect? (IDs, or empty)"
        expects:
          type: id_list
          required: false
      - name: affects_description
        ask: "How does it affect them? (or empty)"
        expects:
          type: string
          required: false
    next: confirm

  confirm:
    type: ask
    context: |
      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      DECISION PREVIEW
      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

      QUESTION:
      {decision_question}

      CONTEXT:
      {decision_context}

      ALTERNATIVES:
      {alternatives | format_numbered}

      CHOICE:
      {choice}

      RATIONALE:
      {rationale}

      DECIDED BY: {decided_by}
      AFFECTS: {affected_nodes | count} nodes

      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    questions:
      - name: confirmed
        ask: "Record this decision?"
        expects:
          type: enum
          options: [record, revise, cancel]
    next: route_confirm

  route_confirm:
    type: branch
    on: "{confirmed}"
    cases:
      record: gather_thoughts
      revise: capture_question
      cancel: cancelled

  cancelled:
    type: complete
    status: cancelled
    message: "Decision not recorded"

  gather_thoughts:
    type: ask
    context: |
      ## Protocol Reflection

      Before creating the decision, share any thoughts on this protocol.
      Your feedback helps improve future executions.

    questions:
      - name: protocol_thoughts
        ask: "Any thoughts or suggestions on how to improve this capture_decision protocol?"
        why_it_matters: "Continuous improvement through reflection"
        good_answer: "Could auto-link to related decisions. Could suggest alternatives based on similar past decisions."
        expects:
          type: string
          required: false

      - name: context_observations
        ask: "Anything about the context or process that could be better?"
        expects:
          type: string
          required: false

    next: create_decision

  create_decision:
    type: create
    nodes:
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # NODE: Decision (Narrative)
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      - id: "narrative_decision_{decision_question | slugify | truncate(30)}_{timestamp}"
        node_type: narrative
        type: decision
        name: "{decision_question | truncate(50)}"
        question: "{decision_question}"
        context: "{decision_context}"
        alternatives: "{alternatives | to_json}"
        choice: "{choice}"
        rationale: "{rationale}"
        decided_by: "{decided_by}"
        decision_date: "{decision_date}"
        affects_description: "{affects_description}"
        weight: 0.85
        # ━━━ ATTRIBUTE EXPLANATIONS ━━━
        #
        # id: "narrative_decision_{decision_question | slugify | truncate(30)}_{timestamp}"
        #   WHAT: Unique identifier for this decision
        #   WHY: Used to query and reference this decision
        #   FORMAT: narrative_decision_<slug>_<timestamp>
        #
        # node_type: narrative
        #   WHAT: Persistent story/record (vs moment = event)
        #   WHY: Decisions are permanent records, not events
        #   ALTERNATIVES: moment (point-in-time), space (container)
        #
        # type: decision
        #   WHAT: Categorization within narratives
        #   WHY: Enables queries like "show all decisions"
        #   OTHER_TYPES: escalation, todo, investigation
        #
        # name: "{decision_question | truncate(50)}"
        #   WHAT: Short human-readable title
        #   WHY: Displayed in lists and summaries
        #   LENGTH: Truncated to 50 chars for scanability
        #
        # question: "{decision_question}"
        #   WHAT: The question being decided
        #   WHY: Frames the decision as a choice to be made
        #   QUALITY: Should be specific, answerable question
        #
        # context: "{decision_context}"
        #   WHAT: What led to this decision point
        #   WHY: Provides background for understanding the choice
        #   LENGTH: 20+ chars, specific about circumstances
        #
        # alternatives: "{alternatives | to_json}"
        #   WHAT: JSON array of options considered
        #   WHY: Shows what was evaluated, not just what was chosen
        #   FORMAT: [{"label": "A", "description": "...", "pros": "...", "cons": "..."}]
        #
        # choice: "{choice}"
        #   WHAT: Which alternative was selected
        #   WHY: Records the actual decision made
        #   QUALITY: Should reference specific alternative
        #
        # rationale: "{rationale}"
        #   WHAT: Why this choice over alternatives
        #   WHY: Captures reasoning for future reference
        #   LENGTH: 20+ chars, explains tradeoffs
        #
        # decided_by: "{decided_by}"
        #   WHAT: Who made this decision
        #   WHY: Attribution for accountability and context
        #   EXAMPLE: "Nicolas", "Architecture Team"
        #
        # decision_date: "{decision_date}"
        #   WHAT: When this was decided
        #   WHY: Temporal context for understanding constraints
        #   FORMAT: ISO date or "now"
        #
        # affects_description: "{affects_description}"
        #   WHAT: How this decision impacts other nodes
        #   WHY: Explains ripple effects and dependencies
        #   USAGE: Helps understand decision's scope
        #
        # weight: 0.85
        #   WHAT: Importance score (0.0-1.0)
        #   WHY: Decisions are high priority (0.85)
        #   RANGE: 0.9 for escalations, 0.85 for decisions, 0.7 for todos

      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # NODE: Decision Moment
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      - id: "moment_decision_{timestamp}"
        node_type: moment
        type: decision_recorded
        text: |
          Decision recorded: {decision_question | truncate(50)}

          Choice: {choice}
          Rationale: {rationale | truncate(100)}
        status: completed
        # ━━━ ATTRIBUTE EXPLANATIONS ━━━
        #
        # id: "moment_decision_{timestamp}"
        #   WHAT: Unique ID with timestamp for ordering
        #   WHY: Moments are ordered chronologically
        #   FORMAT: moment_<action>_<timestamp>
        #
        # node_type: moment
        #   WHAT: Point-in-time event record
        #   WHY: Creates history that can be queried
        #   CONTRAST: narratives persist, moments are events
        #
        # type: decision_recorded
        #   WHAT: Categorizes this moment type
        #   WHY: Enables queries like "show all decision events"
        #   OTHER_TYPES: escalation_raised, escalation_resolved
        #
        # text: "Decision recorded..."
        #   WHAT: Human-readable description
        #   WHY: Displayed in activity feeds and history
        #   FORMAT: Past tense, includes choice + rationale
        #
        # status: completed
        #   WHAT: Moment state
        #   WHY: "completed" = action finished successfully
        #   OPTIONS: completed, pending, cancelled

    links:
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # LINK: Space Contains Decision
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      - type: contains
        from: "{space_id}"
        to: "narrative_decision_{decision_question | slugify | truncate(30)}_{timestamp}"
        # ━━━ LINK EXPLANATION ━━━
        #
        # type: contains
        #   WHAT: Parent-child relationship
        #   WHY: Establishes hierarchy - space contains decision
        #   QUERY: "What decisions are in space X?" follows contains
        #   DIRECTION: from=space, to=decision

      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # LINK: Decision Affects Nodes
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      - for_each: affected_nodes
        type: relates
        from: "narrative_decision_{decision_question | slugify | truncate(30)}_{timestamp}"
        to: "{item}"
        properties:
          direction: affects
        # ━━━ LINK EXPLANATION ━━━
        #
        # type: relates
        #   WHAT: Generic relationship with direction property
        #   WHY: "affects" is a specific semantic relationship
        #   QUERY: "What decisions affect node X?" follows relates inversely
        #   DIRECTION: from=decision, to=affected_node
        #
        # properties.direction: affects
        #   WHAT: Semantic qualifier for the relationship
        #   WHY: Differentiates from other relates types (resolves, spawned_from)
        #   USAGE: Query can filter on direction="affects"

      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # LINK: Moment About Decision
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      - type: about
        from: "moment_decision_{timestamp}"
        to: "narrative_decision_{decision_question | slugify | truncate(30)}_{timestamp}"
        # ━━━ LINK EXPLANATION ━━━
        #
        # type: about
        #   WHAT: Topic/subject relationship
        #   WHY: Records what the moment relates to
        #   QUERY: "What happened to decision X?" follows about
        #   DIRECTION: from=moment, to=decision

      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # LINK: Moment About Space
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      - type: about
        from: "moment_decision_{timestamp}"
        to: "{space_id}"
        # ━━━ LINK EXPLANATION ━━━
        #
        # type: about
        #   WHAT: Topic/subject relationship
        #   WHY: Records what space this event relates to
        #   QUERY: "What happened in space X?" follows about
        #   DIRECTION: from=moment, to=space

      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      # LINK: Actor Expresses Moment
      # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      - type: expresses
        from: "{actor_id}"
        to: "moment_decision_{timestamp}"
        # ━━━ LINK EXPLANATION ━━━
        #
        # type: expresses
        #   WHAT: Attribution link
        #   WHY: Records who/what created this decision
        #   QUERY: "What did agent X decide?" follows expresses
        #   DIRECTION: from=actor, to=moment

    moment:
      agent_provides: [description]
    next: call_handoff

  call_handoff:
    type: call_protocol
    protocol: completion_handoff
    inputs:
      space_id: "{space_id}"
      task_id: "capture_decision_{decision_question | slugify | truncate(30)}_{timestamp}"
    next: $complete

output:
  cluster:
    nodes:
      - narrative_decision
      - moment
    links:
      - contains (space → decision)
      - relates[affects] (decision → affected nodes)
      - about (moment → decision, space)
      - expresses (actor → moment)
  summary: "Recorded decision: {decision_question | truncate(50)} → {choice}"
  returns:
    decision_id: "narrative_decision_{decision_question | slugify | truncate(30)}_{timestamp}"
    moment_id: "moment_decision_{timestamp}"
