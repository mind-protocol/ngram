# Protocol: ingest_docs
# Ingest documentation files into graph and archive originals

protocol: ingest_docs
version: "1.0"
description: Ingest doc files into graph as narratives, then archive originals

triggers:
  - issue: "DOCS_NOT_INGESTED"
  - event: "New documentation needs graph ingestion"

requires_skills:
  - SKILL_Ingest_Docs_To_Graph_And_Archive.md

contextual_knowledge:
  domain: |
    Documentation files must be ingested into the graph to enable:
    - Agent queries across documentation
    - Link traversal between concepts
    - Context loading for tasks

    Chain order determines ingestion priority:
    OBJECTIVES(0) > BEHAVIORS(1) > PATTERNS(2) > ALGORITHM(3) >
    VALIDATION(4) > IMPLEMENTATION(5) > HEALTH(6) > SYNC(7)

  constraints: |
    - Process docs in chain order within each module
    - Verify ingestion before archiving
    - Maintain module grouping for coherent graph structure
    - Archive to data/archive/docs/{module}/

  dependencies: |
    Requires: Graph connection, module space exists
    Enables: Graph queries, agent context loading

  quality_criteria: |
    Good: All OBJECTIVES ingested before BEHAVIORS, all module docs together
    Bad: Random ingestion order, orphaned docs without module context

steps:
  load_context:
    type: query
    auto_fetch:
      - query: { find: issue, type: DOCS_NOT_INGESTED, module: "{module}" }
        store_as: pending_docs
      - query: { find: space, id: "space_MODULE_{module}" }
        store_as: module_space
    computed:
      module_name: "{module | clean_module_name}"
    next: check_module_space

  check_module_space:
    type: branch
    checks:
      - condition: "{module_space | is_empty}"
        action:
          type: call_protocol
          protocol: define_space
          context:
            space_type: MODULE
            name: "{module}"
          on_complete: sort_by_chain
      - condition: "ready"
        action: { goto: sort_by_chain }

  sort_by_chain:
    type: transform
    input: pending_docs
    sort_by: chain_priority
    group_by: chain_type
    store_as: sorted_docs
    next: ingest_loop

  ingest_loop:
    type: foreach
    items: sorted_docs
    as: doc
    steps:
      - read_doc:
          type: read_file
          path: "{doc.path}"
          store_as: doc_content

      - create_narrative:
          type: create
          nodes:
            - id: "narrative_DOC_{module_name}-{doc.chain_type}_{doc.path | hash6}"
              node_type: narrative
              type: documentation
              chain_type: "{doc.chain_type}"
              module: "{module_name}"
              path: "{doc.path}"
              title: "{doc_content | extract_title}"
              content: "{doc_content}"
              weight: 0.8
              created_at_s: "{timestamp}"
              updated_at_s: "{timestamp}"

          links:
            # Space contains doc
            - type: contains
              from: "space_MODULE_{module_name}"
              to: "narrative_DOC_{module_name}-{doc.chain_type}_{doc.path | hash6}"

      - verify_ingestion:
          type: query
          cypher: |
            MATCH (n:Narrative {id: $id})
            RETURN n.id, n.content IS NOT NULL
          params:
            id: "narrative_DOC_{module_name}-{doc.chain_type}_{doc.path | hash6}"
          expect: "row_count > 0"
          on_fail: { error: "Ingestion verification failed for {doc.path}" }

      - archive_original:
          type: move_file
          from: "{doc.path}"
          to: "data/archive/docs/{module_name}/{doc.path | basename}"

    next: create_moment

  create_moment:
    type: create
    nodes:
      - id: "moment_INGEST-DOCS_{module_name}_{timestamp_short}"
        node_type: moment
        type: doc_ingestion
        prose: "Ingested {sorted_docs | count} docs for {module_name}"
        status: completed
        docs_ingested: "{sorted_docs | count}"
        module: "{module_name}"

    links:
      - type: expresses
        from: "{actor_id}"
        to: "moment_INGEST-DOCS_{module_name}_{timestamp_short}"

    next: call_handoff

  call_handoff:
    type: call_protocol
    protocol: completion_handoff
    inputs:
      space_id: "space_MODULE_{module_name}"
      task_id: "ingest_docs_{module_name}"
    next: $complete

output:
  cluster:
    nodes:
      - narrative_DOC (per doc)
      - moment_INGEST-DOCS
    links:
      - contains (space → doc)
      - expresses (actor → moment)
  summary: "Ingested {sorted_docs | count} docs for {module_name}, archived to data/archive/docs/"
  returns:
    docs_ingested: "{sorted_docs | count}"
    module: "{module_name}"
    archive_path: "data/archive/docs/{module_name}/"
    moment: "moment_INGEST-DOCS_{module_name}_{timestamp_short}"
